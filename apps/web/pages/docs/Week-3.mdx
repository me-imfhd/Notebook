
## Week 3.1 

# Middlewares, Global Catches & Zod


**In this lecture, Harkirat dives deep into** `M`**`iddlewares:`** behind-the-scenes helpers that tidy up things before your main code does its thing. `G`**`lobal catches:`** safety nets for your code, they catch unexpected issues before they cause chaos. And finally, `Zod:` a library that ensures efficient input validation on your behalf.



![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/fa622371-9254-4b71-a034-333f3755dbf7/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T145025Z&X-Amz-Expires=3600&X-Amz-Signature=b76bb76ff66c4b30b52949dc577b2347a77888ac1928e90a48adebc610ef85dd&X-Amz-SignedHeaders=host&x-id=GetObject)


# Understanding Middlewares:


**Imagine a Busy Hospital:**


Think of a hospital where there's a doctor, patients waiting in line, and a few helpful assistants making sure everything runs smoothly.

1. **Doctor's Cabin** **`(Application Logic)`** **:**
	- The doctor is like the main brain of our hospital – ready to help patients with their problems.
2. **Waiting Room** **`(Callback Queue)`** **:**
	- The waiting room is where patients hang out before seeing the doctor. Each patient has a unique situation.
3. Intermediates **`(Middlewares)`** **:**
	- Before a patient sees the doctor, there are some helpers doing important tasks.
	- One helper checks if patients have the right paperwork . This is like ensuring everyone is who they say they are `(Authentication)`
	- Another helper does quick health checks – like making sure patients' blood pressure is okay. This is similar to checking if the information coming to the doctor is healthy and makes sense `(Input Validation)`

![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/548d509d-be2a-4874-973d-90c9b363547a/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T145025Z&X-Amz-Expires=3600&X-Amz-Signature=ff6032f44766f056af0e2151a5f79deaac0fa79d48b9dd4f972520ffd53f579f&X-Amz-SignedHeaders=host&x-id=GetObject)


## Middlewares in JS Context & Problem Statement:


Earlier we used to organize all our prechecks followed by the application logic all in one route. 


> Middlewares emerged as a solution to enhance code organization by extracting prechecks from the core application logic. The motivation behind their introduction lies in our commitment to the `"Don't Repeat Yourself" (DRY) principle.` 


By isolating these preliminary checks into distinct functions or code blocks known as middlewares, we achieve a more modular and maintainable codebase. This separation not only streamlines the primary application logic but also promotes code reuse, making it easier to manage, understand, and scale our software architecture.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/daf25e04-e7a6-4446-8037-f62b1982c10e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T145025Z&X-Amz-Expires=3600&X-Amz-Signature=0248bbe7cfee2691094be3db606fcf776dba13feafeaf42cb0875454445940d2&X-Amz-SignedHeaders=host&x-id=GetObject)


## Solution: Middlewares



![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/751201d4-a495-414a-8541-5d95d43f34a2/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T145025Z&X-Amz-Expires=3600&X-Amz-Signature=2aa68dff6cdedff50e2ae645075e1ecc4b0fec7e65668685e9d09fc5827fa15f&X-Amz-SignedHeaders=host&x-id=GetObject)


> Furthermore, with middleware, we can easily include as many precheck functions as needed. This means we have the freedom to add various checks or operations to our application without making the main code complex. It's like having building blocks that we can mix and match to create a customized process for our application, making it more adaptable and easier to manage. Here `userMiddleware` and `kidneyMiddleware`


## Some Associated Concepts:


### 1. `next()` Keyword:


In middleware functions in Express, `next` is a callback function that is used to pass control to the next middleware function in the stack. When you call `next()`, it tells Express to move to the next middleware in line. If `next()` is not called within a middleware function, the request-response cycle stops, and the client receives no response.


Example:


```javascript
app.use((req, res, next) => {
  console.log('This middleware runs first.');
  next(); // Move to the next middleware
});

app.use((req, res) => {
  console.log('This middleware runs second.');
  res.send('Response sent from the second middleware.');
});

```


### 2. Difference between `res.send` and `res.json`:

- `res.send`: Sends a response of various types (string, Buffer, object, etc.). Express tries to guess the content type based on the data provided.

	```javascript
	res.send('Hello, World!'); // Sends a plain text response
	
	```

- `res.json`: Sends a JSON response. It automatically sets the `Content-Type` header to `application/json`.

	```javascript
	res.json({ message: 'Hello, JSON!' }); // Sends a JSON response
	
	```


### 3. Importance of `app.use(express.json())`:


`app.use(express.json())` is middleware that parses incoming JSON payloads in the request body. It is crucial when dealing with JSON data sent in the request body, typically in POST or PUT requests. Without this middleware, you might receive the JSON data as a raw string, and you'd need to manually parse it.


Example:


```javascript
const express = require('express');
const app = express();

app.use(express.json()); // Middleware to parse JSON in the request body

app.post('/api/data', (req, res) => {
  const jsonData = req.body; // Now req.body contains the parsed JSON data
  // Process the data...
  res.json({ success: true });
});

```


### 4. Middleware and `req.body`:

- `req.query` and `req.headers` don't require middleware because they represent the query parameters and headers of the incoming request, respectively. Express automatically parses them.
- `req.body` requires middleware like `express.json()` to parse the request body, especially when the body contains JSON data. Other middleware, like `express.urlencoded()`, is used for parsing form data in the request body.

Middleware helps in processing the request at different stages and is essential for tasks like parsing, logging, authentication, and more in a modular and organized way.


# 
3 Ways of Sending Inputs to a Response:


### **1. Query Parameter:**

- **What it is:** Like giving specific instructions in the web address.
- **Example:** In **`www.example.com/search?topic=animals`**, the query parameter is **`topic`** with the value **`animals`**.
- **Use Case:** Good for simple stuff you want everyone to see, like search terms in a URL.

### **2. Body:**

- **What it is:** Imagine it as the hidden part of a request, carrying more detailed information.
- **Example:** When you fill out a form on a website, the details you enter (name, email) go in the body of the request.
- **Use Case:** Great for sending lots of information, especially when you're submitting something like a form.

### **3. Headers:**

- **What it is:** Extra information attached to the request, kind of like details about a letter.
- **Example:** Headers could include things like your identity or the type of data you're sending.
- **Use Case:** Perfect for passing along special information that doesn't fit neatly in the URL or body, like who you are or how to handle the data.

### **Bottom Line:**

- **Query Parameters:** Simple instructions visible in the web address.
- **Body:** Hidden part of the request for more detailed info, great for forms.
- **Headers:** Extra details about the request, useful for special information.

# Global Catches:



It essentially help us the developers give a better error message to the user.


> Global Catch or Error-Handling Middleware is a special type of middleware function in Express that has four arguments instead of three (`(err, req, res, next)`). Express recognizes it as an error-handling middleware because of these four arguments.


```javascript
// Error Handling Middleware
const errorHandler = (err, req, res, next) => {
  console.error('Error:', err);

  // Customize the error response based on your requirements
  res.status(500).json({ error: 'Something went wrong!' });
};
```


### Importance of **Global Error Handling:**

1. **Centralized Handling:**
	- Global catch blocks allow you to centrally manage and handle errors that occur anywhere in your application. Instead of handling errors at each specific location, you can capture and process them in a centralized location.
2. **Consistent Error Handling:**
	- Using a global catch mechanism ensures a consistent approach to error handling throughout the application. You can define how errors are logged, reported, or displayed in one place, making it easier to maintain a uniform user experience.
3. **Fallback Mechanism:**
	- Global catches often serve as a fallback mechanism. If an unexpected error occurs and is not handled locally, the global catch can capture it, preventing the application from crashing and providing an opportunity to log the error for further analysis.

# Input Validation:


Input validation is a crucial aspect of securing your application. It helps ensure that the data received by your server is in the expected format and meets certain criteria.

Take for instance a login schema, now instead of passing a username and password in the body, the user can pass in any gibberish and may try to crash the server. Thus, it is our responsibility to ensure that our application logic handles all these input vulnerabilities.

Let's explore two approaches to input validation: the naive way with multiple `if-else` statements and using the **`zod`** library for schema validation.


### 1. Naive Way - Multiple If-Else Statements:


In the naive approach, you manually check each input parameter to ensure it meets your criteria. Here's an example using Express.js:


```javascript
const express = require('express');
const app = express();

app.use(express.json());

app.post('/login', (req, res) => {
  const { username, password } = req.body;

  if (!username || typeof username !== 'string' || username.length < 3 ||
      !password || typeof password !== 'string' || password.length < 6) {
    return res.status(400).json({ error: 'Invalid input.' });
  }

  // Proceed with authentication logic
  // ...

  res.json({ success: true });
});

const PORT = 3000;
app.listen(PORT, () => console.log(`Server is running on http://localhost:${PORT}`));
```


In this example, we manually check the `username` and `password` fields for their existence, data type, and minimum length. This approach can become cumbersome as the number of input parameters increases, and it may lead to code duplication.


### 2. Using `zod` Library for Schema Validation:


`zod` is a TypeScript-first schema declaration and validation library. It provides a concise way to define schemas and validate input data. Here's an example using `zod` for the same login scenario:


```javascript
const express = require('express');
const { z } = require('zod');
const app = express();

app.use(express.json());

const loginSchema = z.object({
  username: z.string().min(3),
  password: z.string().min(6),
});

app.post('/login', (req, res) => {
  const { username, password } = req.body;

  try {
    loginSchema.parse({ username, password });
    // Proceed with authentication logic
    // ...
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: 'Invalid input.', details: error.errors });
  }
});

const PORT = 3000;
app.listen(PORT, () => console.log(`Server is running on http://localhost:${PORT}`));
```


In this example, we define a `loginSchema` using `zod` that specifies the expected structure and constraints for the input data. The `parse` method is then used to validate the input against the schema. If the input is invalid, `zod` throws an error, and we can handle it appropriately. This approach is more concise and less error-prone compared to the manual if-else checks.


# Zod:


Zod is a TypeScript-first schema declaration and validation library. It provides a simple and expressive way to define the structure and constraints of your data, allowing you to easily validate and parse input against those specifications. Here's a brief explanation of Zod and its syntax:


### Zod Syntax Overview:

1. **Basic Types:**
	- Zod provides basic types such as `string`, `number`, `boolean`, `null`, `undefined`, etc.

		```javascript
		const schema = z.string();
		```

2. **Object Schema:**
	- You can define the structure of an object using the `object` method and specify the shape of its properties.

		```javascript
		const userSchema = z.object({
		  username: z.string(),
		  age: z.number(),
		});
		```

3. **Nested Schemas:**
	- You can nest schemas within each other to create more complex structures.

		```javascript
		const addressSchema = z.object({
		  street: z.string(),
		  city: z.string(),
		});
		
		const userSchema = z.object({
		  username: z.string(),
		  address: addressSchema,
		});
		```

4. **Array Schema:**
	- You can define the schema for arrays using the `array` method.

		```javascript
		const numbersSchema = z.array(z.number());
		```

5. **Union and Intersection Types:**
	- Zod supports union and intersection types for more flexibility.

		```javascript
		const numberOrStringSchema = z.union([z.number(), z.string()]);
		const combinedSchema = z.intersection([userSchema, addressSchema]);
		```

6. **Optional and Nullable:**
	- You can make properties optional or nullable using `optional` and `nullable` methods.

		```javascript
		const userSchema = z.object({
		  username: z.string(),
		  age: z.optional(z.number()),
		  email: z.nullable(z.string()),
		});
		```

7. **Custom Validators:**
	- Zod allows you to define custom validation logic using the `refine` method.

		```javascript
		const positiveNumberSchema = z.number().refine((num) => num > 0, {
		  message: 'Number must be positive',
		});
		```

8. **Parsing and Validation:**
	- To validate and parse data, use the `parse` method. If the data is invalid, it throws an error with details about the validation failure.

		```javascript
		try {
		  const userData = userSchema.parse({
		    username: 'john_doe',
		    age: 25,
		    address: {
		      street: '123 Main St',
		      city: 'Exampleville',
		    },
		  });
		  console.log('Parsed data:', userData);
		} catch (error) {
		  console.error('Validation error:', error.errors);
		}
		```


### Why Zod:

- **TypeScript-First Approach:** Zod is designed with TypeScript in mind, providing strong type-checking and autocompletion for your schemas.
- **Concise and Expressive Syntax:** Zod's syntax is concise and expressive, making it easy to define complex data structures with minimal code.
- **Validation and Parsing:** Zod not only validates data but also automatically parses it into the expected TypeScript types.
- **Rich Set of Features:** Zod includes a variety of features, such as custom validation, optional and nullable types, union and intersection types, making it a powerful tool for data validation in your applications.

Overall, Zod simplifies the process of declaring and validating data structures, reducing the likelihood of runtime errors and improving the overall robustness of your code.


## Week 3.2

# Authentication & Databases


In this focused lecture, Harkirat covers crucial `async concepts`—Fetch, callbacks, promises, and async/await—as well as delves into `Authentication` strategies and `Databases`, specifically the `MongoDB` database.



# fetch() Method


The `fetch()` method in JavaScript is a modern API that allows you to make network requests, typically to retrieve data from a server. It is commonly used to interact with web APIs and fetch data asynchronously. Here's a breakdown of what the `fetch()` method is and why it's used:


### What is the `fetch()` Method?


The `fetch()` method is a built-in JavaScript function that simplifies making HTTP requests. It returns a Promise that resolves to the `Response` to that request, whether it is successful or not.


### Why is it Used?

1. **Asynchronous Data Retrieval:**
	- The primary use of the `fetch()` method is to asynchronously retrieve data from a server. Asynchronous means that the code doesn't wait for the data to arrive before moving on. This is crucial for creating responsive and dynamic web applications.
2. **Web API Interaction:**
	- Many web applications interact with external services or APIs to fetch data. The `fetch()` method simplifies the process of making HTTP requests to these APIs.
3. **Promise-Based:**
	- The `fetch()` method returns a Promise, making it easy to work with asynchronous operations using the `.then()` and `.catch()` methods. This promotes cleaner and more readable code.
4. **Flexible and Powerful:**
	- `fetch()` is more flexible and powerful compared to older methods like `XMLHttpRequest`. It supports a wide range of options, including headers, request methods, and handling different types of responses (JSON, text, etc.).

### Basic Example:


Here's a basic example of using the `fetch()` method to retrieve data from a server:


```javascript
fetch('<https://api.example.com/data>')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    console.log('Data from server:', data);
  })
  .catch(error => {
    console.error('Fetch error:', error);
  });
```


In this example, we use `fetch()` to make a GET request to '[https://api.example.com/data](https://api.example.com/data)', handle the response, and then parse the JSON data. The `.then()` and `.catch()` methods allow us to handle the asynchronous flow and potential errors.


# Some Asynchronous Concepts


## 1. **Callback Functions:**


**Definition:**
A callback function is a function that is passed as an argument to another function and is executed after the completion of that function.


**Example:**


```javascript
function fetchData(callback) {
  // Simulating an asynchronous operation
  setTimeout(() => {
    const data = 'Hello, callback!';
    callback(data);
  }, 1000);
}

// Using the callback function
fetchData(result => {
  console.log(result);
});
```


**Relation to** **`fetch()`****:**
In older JavaScript code or libraries, callbacks were extensively used for handling asynchronous operations, such as handling the response in the `.then()` block of `fetch()`.


## 2. **Promises:**


**Definition:**
A Promise is an object representing the eventual completion or failure of an asynchronous operation. It is a more structured and readable way to handle asynchronous code compared to callbacks.


**Example:**


```javascript
function fetchData() {
  return new Promise((resolve, reject) => {
    // Simulating an asynchronous operation
    setTimeout(() => {
      const success = true;
      if (success) {
        const data = 'Hello, Promise!';
        resolve(data);
      } else {
        reject('Oops! Something went wrong.');
      }
    }, 1000);
  });
}

// Using the Promise
fetchData()
  .then(result => {
    console.log(result);
  })
  .catch(error => {
    console.error(error);
  });

```


**Relation to** **`fetch()`****:**
The `fetch()` method returns a Promise. We use `.then()` to handle the resolved value (successful response) and `.catch()` for handling errors.


## 3. **Async/Await:**


**Definition:**`async/await` is a syntactic sugar built on top of Promises, making asynchronous code more readable and easier to write.


**Example:**


```javascript
async function fetchData() {
  return new Promise(resolve => {
    // Simulating an asynchronous operation
    setTimeout(() => {
      const data = 'Hello, Async/Await!';
      resolve(data);
    }, 1000);
  });
}

// Using async/await
async function fetchDataAndPrint() {
  try {
    const result = await fetchData();
    console.log(result);
  } catch (error) {
    console.error(error);
  }
}

// Invoking the async function
fetchDataAndPrint();
```


**Relation to** **`fetch()`****:**
In the context of `fetch()`, `async/await` provides a more synchronous-looking code structure when dealing with asynchronous operations, especially when handling responses.


## **Overall Relationship:**

- Callbacks were the traditional way of handling asynchronous code.
- Promises introduced a more structured and readable way to handle async operations.
- `async/await` builds on top of Promises, offering a more synchronous coding style, making asynchronous code look similar to synchronous code.

**Example Combining All:**


```javascript
function fetchData(callback) {
  setTimeout(() => {
    const data = 'Hello, Callback!';
    callback(data);
  }, 1000);
}

function fetchDataPromise() {
  return new Promise(resolve => {
    setTimeout(() => {
      const data = 'Hello, Promise!';
      resolve(data);
    }, 1000);
  });
}

async function fetchDataAsyncAwait() {
  return new Promise(resolve => {
    setTimeout(() => {
      const data = 'Hello, Async/Await!';
      resolve(data);
    }, 1000);
  });
}

// Using callback
fetchData(result => {
  console.log(result);

  // Using Promise
  fetchDataPromise()
    .then(result => {
      console.log(result);

      // Using Async/Await
      fetchDataAsyncAwait()
        .then(result => {
          console.log(result);
        })
        .catch(error => {
          console.error(error);
        });
    })
    .catch(error => {
      console.error(error);
    });
});
```


In this example, we've shown the use of callback, Promise, and Async/Await together. Async/Await provides a cleaner and more readable way to structure asynchronous code, especially when dealing with multiple async operations.


## 4. Try Catch Blocks


In JavaScript and many other programming languages, a `try-catch` block is a mechanism for handling exceptions or errors in a structured way. This construct is crucial for writing robust and fault-tolerant code. 


### Purpose:


The primary purpose of a `try-catch` block is to gracefully handle runtime errors or exceptions that may occur during the execution of a program. It allows developers to anticipate potential issues and implement a fallback strategy, preventing abrupt program termination.


### Syntax:


The basic syntax of a `try-catch` block is as follows:


```javascript
try {
  // Code that may throw an exception
} catch (error) {
  // Code to handle the exception
}
```

- The `try` block encloses the code that might generate an exception.
- If an exception occurs, the control is transferred to the `catch` block, where the `error` parameter holds information about the exception.

### How It Works:

1. **Execution in the Try Block:**
	- Code inside the `try` block is executed sequentially.
	- If an exception occurs at any point, the normal flow of execution is interrupted.
2. **Control Transfer to Catch Block:**
	- When an exception is thrown, control is transferred to the corresponding `catch` block.
	- The `catch` block is responsible for handling the exception.
3. **Exception Handling:**
	- Inside the `catch` block, developers can implement error-handling logic.
	- They can log the error, display a user-friendly message, or take alternative actions to recover from the error.

### Example:


```javascript
try {
  // Code that may throw an exception
  const result = 10 / 0; // Division by zero, will throw an exception
  console.log(result); // This line won't be executed
} catch (error) {
  // Code to handle the exception
  console.error('An error occurred:', error.message); // Output: An error occurred: Cannot divide by zero
} finally {
  // Code inside the finally block will execute regardless of whether an exception occurred or not
  console.log('Finally block executed');
}
```

- In this example, a division by zero operation inside the `try` block will throw an exception.
- The control is then transferred to the `catch` block, where an error message is logged.
- The `finally` block, if present, will always execute, providing an opportunity for cleanup or finalization tasks.

# Authentication


In a programming context, authentication refers to the process of validating the identity of a user, system, or application attempting to access a computer system, network, or online service. The primary goal is to ensure that the entity requesting access is indeed who it claims to be. Authentication is a crucial aspect of software development, especially in scenarios where user access to sensitive data or functionalities needs to be controlled. Here's how authentication is typically implemented in programming:


## 1. **Hashing:**


**Purpose:**

- Hashing is a one-way process that converts a password or any data into a fixed-size string of characters, which is typically a hash value. The primary purpose of hashing passwords before storing them in a database is to enhance security.

**How it Works:**

- When a user signs up and provides a password, the application hashes the password using a cryptographic hash function (e.g., bcrypt, SHA-256).
- The resulting hash is a fixed-length string unique to the input, making it difficult to reverse engineer the original password.

**Why Hash Passwords:**

- **Security:** Hashing prevents storing plaintext passwords in the database, reducing the risk of data breaches. Even if the database is compromised, attackers only obtain hashed values, which are challenging to convert back to the original passwords.

**Example in Node.js using bcrypt:**


```javascript
const bcrypt = require('bcrypt');

// Hashing a password
const plainPassword = 'user123';
bcrypt.hash(plainPassword, 10, (err, hash) => {
  if (err) throw err;
  console.log('Hashed Password:', hash);

  // Verify a password
  bcrypt.compare('user123', hash, (err, result) => {
    if (err) throw err;
    console.log('Password Match:', result);
  });
});
```


## 2. **Encryption:**


**Purpose:**

- Unlike hashing, encryption is a two-way process that involves converting data into a format that can be easily reversed using a decryption key. Encryption is used to protect the confidentiality of data.

**How it Works:**

- Users' sensitive information (e.g., credit card details) may be encrypted before storing it in a database.
- To view or use the original data, a decryption key is required.

**Why Use Encryption:**

- **Confidentiality:** Encrypting sensitive data adds an extra layer of security. Even if unauthorized access occurs, the data remains unreadable without the decryption key.

**Example in Node.js using crypto:**


```javascript
const crypto = require('crypto');

// Encryption
const dataToEncrypt = 'Sensitive information';
const encryptionKey = 'secretKey';
const cipher = crypto.createCipher('aes-256-cbc', encryptionKey);
let encryptedData = cipher.update(dataToEncrypt, 'utf-8', 'hex');
encryptedData += cipher.final('hex');
console.log('Encrypted Data:', encryptedData);

// Decryption
const decipher = crypto.createDecipher('aes-256-cbc', encryptionKey);
let decryptedData = decipher.update(encryptedData, 'hex', 'utf-8');
decryptedData += decipher.final('utf-8');
console.log('Decrypted Data:', decryptedData);
```


## 3. JSON Web Tokens (JWT)


A JSON Web Token, or JWT, is like a digital passport for information. It's a special kind of code that carries details about a user or some data. Imagine you have a passport when you travel to different countries – the passport holds your information and proves who you are. Similarly, a JWT carries information and proves certain things about you or the data it holds.


### How Does JWT Look?


A JWT is made up of three parts, and they are separated by dots:

1. **Header:** This part says how the JWT is encoded (like secret coding instructions).
2. **Payload:** This part holds the actual information or claims. For example, it might say who you are and when the JWT was created.
3. **Signature:** This part ensures that the JWT hasn't been tampered with. It's like a seal that shows the information is genuine.

When you put these parts together, you get a long string that looks like a secret code.


### How Do JWTs Work?

1. **Getting the JWT:**
	- Imagine you log in to a website. After you enter your username and password, the website creates a JWT just for you.
2. **Using the JWT:**
	- Now, instead of asking you for your username and password every time you click on something, the website sends your JWT with each request. It's like having a special pass – once you show it, the website knows it's you.
3. **Checking the JWT:**
	- The website has a special key to check if the JWT is real. If everything is okay, the website knows the information in the JWT is trustworthy.

## 4. Local Storage


Local Storage is a client-side web storage mechanism that allows websites to store key-value pairs persistently on a user's device. In the realm of authentication, Local Storage often plays a crucial role in maintaining user sessions and preserving authentication tokens.


### Technical Implementation:

1. **Token Storage:**
	- After a successful authentication, the server generates an authentication token (e.g., JWT) for the user.
	- This token is securely stored in the Local Storage of the user's browser.
2. **Session Persistence:**
	- Local Storage provides a means to persistently store this token across browser sessions. This persistence ensures that the user remains authenticated even if they close the browser and return later.
3. **Reducing Authentication Overhead:**
	- Instead of requiring users to authenticate themselves on every interaction, the stored token allows the server to recognize and validate the user swiftly, enhancing the user experience.

### Benefits of Local Storage in Authentication:

1. **Efficient Session Management:**
	- Local Storage facilitates efficient session management by enabling the storage of authentication tokens client-side. This reduces the need for frequent server-side authentication checks.
2. **Improved Performance:**
	- Since authentication tokens are readily available locally, the authentication process becomes faster, contributing to an improved overall performance of the application.
3. **Enhanced User Experience:**
	- Users experience the convenience of being automatically recognized and authenticated without the hassle of repeated logins, contributing to a seamless and user-friendly interface.

> Local Storage serves as a valuable tool in the authentication landscape, contributing to efficient session management and enhanced user experiences. However, its use should be tempered with a keen awareness of security considerations, adherence to best practices, and a strategic approach to token management.


## Authorization Header


Authorization header is a crucial component of HTTP requests that plays a key role in authenticating and authorizing users or clients to access certain resources on a server.


The Authorization header is used to transmit credentials (such as tokens or API keys) from the client to the server. These credentials are then verified by the server to determine whether the client has the necessary permissions to access the requested resource.


The Authorization header typically follows this basic structure:


```text
Authorization: <type> <credentials>
```

- **Type:** Specifies the type of credentials being sent. Common types include "Bearer" for token-based authentication and "Basic" for basic authentication.
- **Credentials:** The actual credentials, which could be a token, username and password combination, or other relevant information, depending on the chosen authentication type.

**Bearer Token Authentication Type:**

- Example: `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`
- Used in token-based authentication (e.g., JSON Web Tokens or OAuth), where a token represents the user's identity and permissions.

### How it Works:

1. **Client Request:**
	- The client includes the Authorization header in an HTTP request when accessing a secured resource.
2. **Server Verification:**
	- The server receives the request and extracts the credentials from the Authorization header.
3. **Credential Verification:**
	- The server verifies the credentials, usually by checking against a user database, validating a token, or using other authentication mechanisms.
4. **Access Decision:**
	- Based on the verification result, the server decides whether to grant or deny access to the requested resource.

### Example Code (Node.js using Axios):


```javascript
const axios = require('axios');

const url = '<https://api.example.com/resource>';
const token = 'your-access-token';

axios.get(url, {
  headers: {
    'Authorization': `Bearer ${token}`
  }
})
  .then(response => console.log(response.data))
  .catch(error => console.error('Error:', error));
```


In this example, the Bearer token is included in the Authorization header of an Axios HTTP GET request.


## **Cookies vs. Local Storage for Storing JWT Tokens:**


When it comes to storing JWT (JSON Web Tokens), both cookies and local storage are commonly used, but they have distinct characteristics and use cases. Here's a comparison to help you choose the appropriate option for your specific scenario:


### 1. **Cookies:**

- **Security:**

	Cookies can be more secure than local storage because they have an additional security feature called HTTP-only. When a cookie is marked as HTTP-only, it cannot be accessed by JavaScript, reducing the risk of cross-site scripting (XSS) attacks.

- **Automatic Handling:**

	Cookies are automatically sent with every HTTP request to the domain, including requests for images, stylesheets, and scripts. This automatic handling can be advantageous for authenticating API requests made by the browser.

- **Expiration:**

	Cookies can have an expiration date, allowing the server to set a specific duration for which the token is valid. After expiration, the browser automatically removes the cookie.

- **Domain Restriction:**

	Cookies can be set to be domain-restricted, meaning they are only sent to the server from the same domain that set the cookie. This provides a level of security.


### 2. **Local Storage:**

- **Ease of Use:**

	Local storage is easier to use from a JavaScript perspective. You can set, get, and remove items directly using JavaScript without additional HTTP requests.

- **Capacity:**

	Local storage generally has a larger storage capacity compared to cookies.

- **No Automatic Handling:**

	Unlike cookies, local storage data is not automatically sent with every HTTP request. This means you need to manually attach the token to the headers of your API requests if you're using it for authentication.

- **No Expiration Handling:**

	Local storage does not provide built-in expiration handling. If you want to implement token expiration, you need to manage it manually in your code.


**Choosing Between Cookies and Local Storage:**

- **For Authentication:**

	Use cookies with HTTP-only flag for enhanced security, especially if you need to make authenticated API requests directly from the browser.

- **For Client-Side Interactions:**

	Use local storage if you primarily need to access the token on the client side and manage API requests manually.

- **Considerations:**

	Consider factors like security, automatic handling, and token expiration requirements when making your decision.


> In many cases, a combination of both cookies and local storage might be used. Cookies can be employed for secure, HTTP-only storage, while local storage can be used for easy client-side access.


## fetch() vs axios()


### Fetch API

1. **Native Browser API:**
	- `fetch` is a native JavaScript function built into modern browsers for making HTTP requests.
2. **Promise-Based:**
	- It returns a Promise, allowing for a more modern asynchronous coding style with `async/await` or using `.then()`.
3. **Lightweight:**
	- `fetch` is lightweight and comes bundled with browsers, reducing the need for external dependencies.

Example Usage:


```javascript
fetch('<https://api.example.com/data>')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```


### Axios

1. **External Library:**
	- Axios is a standalone JavaScript library designed to work in both browsers and Node.js environments.
2. **Promise-Based:**
	- Similar to `fetch`, Axios also returns a Promise, providing a consistent interface for handling asynchronous operations.
3. **HTTP Request and Response Interceptors:**
	- Axios allows the use of interceptors, enabling the modification of requests or responses globally before they are handled by `then` or `catch`.
4. **Automatic JSON Parsing:**
	- Axios automatically parses JSON responses, simplifying the process compared to `fetch`.

Example Usage:


```javascript
import axios from 'axios';

axios.get('<https://api.example.com/data>')
  .then(response => console.log(response.data))
  .catch(error => console.error('Error:', error));
```


### Comparison Points


1. **Syntax:**

- `fetch` uses a chain of `.then()` to handle responses, which might lead to a more verbose syntax. Axios, on the other hand, provides a concise syntax with `.then()` directly on the Axios instance.

2. **Handling HTTP Errors:**

- Both `fetch` and Axios allow error handling using `.catch()` or `.finally()`, but Axios may provide more detailed error information by default.

3. **Interceptors:**

- Axios provides a powerful feature with interceptors for both requests and responses, allowing global modifications. `fetch` lacks built-in support for interceptors.

4. **Request Configuration:**

- Axios allows detailed configuration of requests through a variety of options. `fetch` may require more manual setup for headers, methods, and other configurations.

5. **JSON Parsing:**

- Axios automatically parses JSON responses, while with `fetch`, you need to manually call `.json()` on the response.

6. **Browser Support:**

- `fetch` is natively supported in modern browsers, but if you need to support older browsers, you might need a polyfill. Axios has consistent behavior across various browsers and does not rely on native implementations.

7. **Size:**

- `fetch` is generally considered lightweight, being a part of the browser. Axios, being a separate library, introduces an additional file size to your project.

### Conclusion

- **Use** **`fetch`** **when:**
	- Working on a modern project without the need for additional features.
	- Prefer a lightweight solution and have no concerns about polyfills.
- **Use Axios when:**
	- Dealing with more complex scenarios such as interceptors.
	- Needing consistent behavior across different browsers.
	- Desiring a library with built-in features like automatic JSON parsing.

> In summary, both `fetch` and Axios have their strengths, and the choice depends on the specific requirements and preferences of the project. `fetch` is excellent for simplicity and lightweight projects, while Axios provides additional features and consistent behavior across different environments.


# Databases


**Until now, we’ve been storing data in memory. This is bad for a few reasons:**


**1. Data can’t be dynamic:**

- When data is stored in memory, it becomes volatile. Any updates or changes made to in-memory objects are temporary and get lost if the process restarts. In a real-world application, this limitation is significant because processes may restart due to various reasons, such as server maintenance, deployments, or unexpected crashes. As a result, any dynamically updated information will be lost, leading to inconsistencies and potential data loss.

**Example:**

- Imagine an application that keeps track of user sessions or preferences. If this data is only stored in memory and the server restarts, all the user-related information would be reset, impacting the user experience.

**2. There are multiple servers in the real world:**

- In a real-world application, especially those handling a significant user load or operating across multiple servers, relying solely on in-memory storage is impractical. Multiple servers may be used to distribute the load, enhance performance, and ensure high availability. When data is confined to the memory of a single server, it becomes challenging to maintain consistency and share data across the entire application infrastructure.

**Example:**

- Consider an e-commerce platform with multiple servers handling user requests. If each server maintains its own set of in-memory data, it becomes challenging to synchronize and share information seamlessly across all servers, leading to potential discrepancies in the displayed data.

> Using databases, not just memory, is vital for strong, scalable apps. They ensure lasting, shared data across servers, maintaining consistency even after restarts.


## Types Of Databases

1. **Graph Databases:**

	Graph databases specialize in representing and navigating relationships between entities, making them ideal for applications emphasizing connected data. _Example:_ Neo4j

2. **Vector Databases:**

	Vector databases efficiently handle multidimensional and spatial relationships, particularly suited for applications dealing with spatial data. _Example:_ InfluxDB

3. **SQL Databases:**

	SQL databases follow a structured query language, maintaining a tabular structure for organized data storage, retrieval, and manipulation. _Example:_ PostgreSQL

4. **NoSQL Databases:**

	NoSQL databases offer flexibility in data modeling and are suitable for applications with evolving and diverse data needs. _Example:_ MongoDB


Today's class will delve into MongoDB, a famous NoSQL database, exploring its features and applications in the world of data management.


## MongoDB


MongoDB is a powerful and versatile NoSQL database that revolutionizes data management with its flexible and scalable design. Here's a breakdown of its key features:

1. **Database Creation:**
	- MongoDB allows users to create multiple databases, acting as distinct containers for organizing and storing data.
2. **Collection Creation:**
	- Within each database, collections serve as the equivalent of tables in relational databases. Collections provide a structured way to group and manage related documents.
3. **JSON Data Storage:**
	- MongoDB adopts a document-oriented data model, storing information in BSON (Binary JSON) format. This facilitates the storage of JSON-like documents in a flexible and readable manner.
4. **Schemaless Design:**
	- Unlike traditional relational databases, MongoDB is schemaless. This means documents within a collection can have varying structures, enabling easy adaptation to changing data requirements without rigid schema constraints.
5. **Scalability:**
	- MongoDB is designed for horizontal scalability, allowing for the distribution of data across multiple servers or clusters. This horizontal scaling ensures optimal performance as data volumes and user loads increase.
6. **Versatility for Most Use Cases:**
	- MongoDB's adaptability makes it a reliable choice for a diverse range of use cases. Whether handling complex data structures or large datasets, MongoDB can efficiently meet the demands of various applications.

> In essence, MongoDB provides a dynamic and scalable solution for modern data storage needs. Its schemaless design, JSON-based documents, and horizontal scalability make it well-suited for applications where flexibility, scalability, and diverse data types are crucial.


## Creating a free MongoDB instance


Creating a free MongoDB instance typically involves using MongoDB Atlas, the official cloud-based database service provided by MongoDB. Follow these step-by-step instructions to create a free MongoDB instance using MongoDB Atlas:

1. **Visit MongoDB Atlas:**
	- Open your web browser and go to the MongoDB Atlas website: [MongoDB Atlas](https://www.mongodb.com/cloud/atlas).
2. **Sign Up or Log In:**
	- If you don't have an account, click on "Sign Up" to create a new account. If you already have an account, log in using your credentials.
3. **Choose a Plan:**
	- Once logged in, click on the "Get Started Free" button to initiate the process of creating a free MongoDB instance.
4. **Fill in the Form:**
	- Provide the required information in the sign-up form. This includes your email, username, and password.
5. **Create an Organization:**
	- After filling in your information, you'll be prompted to create an organization. Enter a name for your organization, and click "Next."
6. **Create a Project:**
	- Inside your organization, you'll create a project. Choose a name for your project, and click "Next."
7. **Create a Cluster:**
	- In the next step, you'll create a cluster. A cluster is a set of servers that will host your MongoDB databases. Choose the free tier (M0 Sandbox), and select your preferred cloud provider and region.
8. **Configure Cluster Settings:**
	- Configure additional settings for your cluster, such as the cluster name, additional features, and whether you want to enable backups. You can stick with the default settings for now.
9. **Create Cluster:**
	- Click the "Create Cluster" button. MongoDB Atlas will start creating your cluster, and this process may take a few minutes.
10. **Wait for Cluster to Deploy:**
	- Once the cluster is created, you'll see it in the MongoDB Atlas dashboard. Wait for the cluster to be deployed and become available.
11. **Access Your Cluster:**
	- Once your cluster is ready, click on the "CONNECT" button. You can then choose to connect using MongoDB Compass (a GUI tool) or connect using your application.
12. **Whitelist Your IP Address:**
	- Before connecting, you need to whitelist your IP address to ensure secure access. Click on the "Add Your Current IP Address" button.
13. **Create a MongoDB User:**
	- Create a MongoDB user by entering a username and password. This user will be used to connect to your MongoDB instance.
14. **Connect to Your Cluster:**
	- After creating the user, click on the "Choose a Connection Method" button and follow the instructions to connect to your MongoDB cluster.

You can now start using MongoDB for your applications.


## How does the backend connect to the database?


It does so by Express, JWT and Mongoose Libraries. Let's break down how the backend connects to the database using these libraries:

1. **Express:**
	- **Role:** Creates an HTTP server to handle requests and responses.
	- **Connection to Database:** While Express itself doesn't directly connect to the database, it provides a framework for building the server. Endpoints/routes within Express handle requests, and these routes may involve interactions with the database using other libraries like Mongoose.
2. **Jsonwebtokens (JWT) Library:**
	- **Role:** Allows the creation and verification of JSON Web Tokens (JWT).
	- **Connection to Database:** Typically, JWTs are used for authentication. Once a user is authenticated, the backend can include a JWT in the response. This token can be sent by the client in subsequent requests, allowing the backend to identify and authorize the user without the need to store session information on the server.
3. **Mongoose:**
	- **Role:** An Object Data Modeling (ODM) library for MongoDB and Node.js. It provides a structured way to interact with MongoDB.
	- **Connection to Database:** Mongoose simplifies the process of connecting to MongoDB. It allows defining models, schemas, and provides methods for CRUD (Create, Read, Update, Delete) operations. The connection to the MongoDB database is established using Mongoose, providing a higher-level abstraction for working with MongoDB.

In summary, while Express sets up the server, JWT helps with user authentication, and Mongoose facilitates interaction with the MongoDB database. Together, these libraries form a robust backend infrastructure for handling HTTP requests, securing routes, and managing data in the database.


## Mongoose


Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. It provides a higher-level, schema-based abstraction over the MongoDB JavaScript driver. Mongoose acts as a powerful bridge between Node.js applications and MongoDB databases. It streamlines the data modeling process, simplifies interactions with the database, and enhances the overall development experience when working with MongoDB in a Node.js environment.


## Week 3.5 

# Document Object Model (Laisha)


---


In this session, Laisha delves into the `Document Object Model (DOM)`, demystifying the core structure that transforms plain HTML pages into dynamic, interactive web encounters through JavaScript. She also sheds light on NodeList and HTMLCollection, the essential tools for effectively handling clusters of elements.



# DOM


You know how a remote control brings a television to life by letting you change channels and do cool things? Well, in the web world, JavaScript is like that remote control for your HTML page, making it active and dynamic. And the secret sauce behind this magic is the DOM – the Document Object Model.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/fcf2cc84-8725-4251-a4b3-8c634c2b068f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T145141Z&X-Amz-Expires=3600&X-Amz-Signature=9f44e696e87be994e54889824ea85027f8979f17654c6534ebe735fac860451a&X-Amz-SignedHeaders=host&x-id=GetObject)


## **What is DOM?**


So, what's this DOM thing? DOM stands for Document Object Model. It's like the behind-the-scenes framework that JavaScript uses to talk to your browser. Imagine it as the language that JavaScript speaks with your web browser to make things happen on your HTML page.


## **Communication with the Browser**


JavaScript and the browser communicate through a set of tools in this magical interface known as the DOM. These tools include properties, methods, and events. It's like having a language to tell your browser what to do and when to do it.


## **Accessing the DOM**


Okay, how do we get our hands on this DOM magic? Well, accessing the DOM is like reaching for that remote control. In JavaScript, you use commands to grab elements from your HTML page, change their content, or even create new elements. It's like giving instructions to your browser using JavaScript.


## **Possibilities of DOM**


Now, let's talk about the possibilities the DOM opens up. With JavaScript and the DOM, you can:

- Change the content of your webpage dynamically.
- Update styles and layout on the fly.
- Respond to user interactions, like clicks or keyboard inputs.
- Add or remove elements, making your page super interactive.

## **Independence and Consistency**


DOM doesn't pick sides. It's independent of any particular programming language. This means whether you're using JavaScript, Python, or any other language, the DOM provides a consistent way to interact with your document. It's like a universal remote that works with any TV.


**In a Nutshell:**
So, the DOM is your backstage pass to making HTML pages come alive with JavaScript. It's a set of rules and tools that allow you to control, change, and interact with your webpage dynamically. It's like giving your webpage a personality and making it respond to your JavaScript commands.



## **DOM Tree**


The DOM tree, or The Document Object Model tree, is a hierarchical representation of the structure of a web document in the context of web development. It's essentially a way to organize and navigate the elements of an HTML or XML document. Here's a breakdown:

- **Document Object:** At the top of the tree is the Document Object, representing the entire web document.
- **HTML Element:** The HTML element comes next, serving as the container for the entire document.
- **Head and Body Elements:** Within the HTML element, there are two main sections: the Head and the Body. The Head typically contains meta-information, styles, and links to external resources, while the Body holds the primary content visible on the webpage.
- **Further Nesting:** Each of these main sections may contain further nested elements. For instance, the Head could include elements like title, meta, or link, while the Body could include paragraphs, images, buttons, and other content-related elements.

The DOM tree essentially forms a family tree-like structure, where elements are organized in a hierarchy based on their relationships with each other. Understanding the DOM tree is crucial for web developers because it provides a structured way to interact with and manipulate the content of a webpage using programming languages like JavaScript.



## Implementing innerHTML



The below implementation consists of an input field that allows users to enter their name. Accompanying this, a button is present, equipped with an `onclick` attribute that invokes the `displayGreeting` function. Within this function, the entered name is acquired by accessing the value of the input field through `document.getElementById("nameInput").value`. Subsequently, the function utilizes `innerHTML` to dynamically alter the content of the `<p>` element identified by the id "greetingMessage," facilitating the display of a personalized greeting message.


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Name Greeting</title>
</head>
<body>

    <label for="nameInput">Enter Your Name:</label>
    <input type="text" id="nameInput">
    <button onclick="displayGreeting()">Submit</button>

    <p id="greetingMessage"></p>

    <script>
        function displayGreeting() {
            // Get the entered name from the input field
            var enteredName = document.getElementById("nameInput").value;

            // Render the greeting message on the DOM using innerHTML
            document.getElementById("greetingMessage").innerHTML = "Hello, " + enteredName + "!";
        }
    </script>

</body>
</html>
```


# Difference Between HTMLCollection and NodeList:


Both HTMLCollections and NodeLists are collections of nodes in the Document Object Model (DOM) provided by JavaScript, but they have some key differences:


### HTMLCollection:

1. **Live Collection:**
	- **Live:** An HTMLCollection is live, meaning it is automatically updated when the underlying document changes. If elements are added or removed, the HTMLCollection is automatically updated to reflect these changes.
2. **Accessing Elements:**
	- **By Index:** Elements in an HTMLCollection can be accessed using numerical indices, similar to an array.
3. **Methods:**
	- **Limited Methods:** HTMLCollections have a more limited set of methods compared to NodeLists.
4. **Specific to Elements:**
	- **Element-Specific:** HTMLCollections are typically used for collections of HTML elements, such as those returned by `getElementsByTagName` or `getElementsByClassName`.

### NodeList:

1. **Live or Static:**
	- **Live or Static:** A NodeList can be live or static. If it's obtained using `querySelectorAll`, it's static and won't automatically update. If it's obtained by other means, like `childNodes`, it might be live.
2. **Accessing Elements:**
	- **By Index or forEach:** Like HTMLCollection, you can access elements by index. Additionally, NodeList supports the `forEach` method for iteration.
3. **Methods:**
	- **Richer Set of Methods:** NodeLists typically have a broader set of methods compared to HTMLCollections.
4. **Not Limited to Elements:**
	- **Node-Oriented:** NodeLists can include various types of nodes, not just HTML elements. They might include text nodes, comment nodes, etc.

### Practical Considerations:

- **Common Methods:**
	- For general purpose, when using methods like `querySelectorAll`, you will get a NodeList.
- **Live vs. Static:**
	- If you need a live collection that automatically updates, an HTMLCollection might be suitable.
	- If you want a static collection that won't change, or if you need a broader range of methods, a NodeList might be preferable.
- **Usage:**
	- HTMLCollections are often associated with specific methods like `getElementsByClassName` or `getElementsByTagName`.
	- NodeLists are often the result of more generic methods like `querySelectorAll` or properties like `childNodes`.

In summary, the choice between HTMLCollection and NodeList depends on your specific needs, especially regarding the liveliness of the collection and the methods you require for manipulation.






# HTMLCollection


## Finding HTML Elements


### By ID:


To find an HTML element by its ID, you can use the `getElementById` method.


```javascript
var elementById = document.getElementById("yourElementId");
```


### By Tag Name:


To find HTML elements by their tag name, you can use the `getElementsByTagName` method.


```javascript
var elementsByTagName = document.getElementsByTagName("yourTagName");
```


### By Class Name:


To find HTML elements by their class name, you can use the `getElementsByClassName` method.


```javascript
var elementsByClassName = document.getElementsByClassName("yourClassName");
```


### By CSS Selector:


To find HTML elements using CSS selectors, you can use the `querySelector` or `querySelectorAll` methods.


```javascript
var elementBySelector = document.querySelector("yourCSSSelector");
var elementsBySelectorAll = document.querySelectorAll("yourCSSSelector");
```


### By HTML Object Collections:


To find HTML elements using HTML collections, you can use methods like `getElementsByName` or `getElementsByName` in specific cases.


```javascript
var elementsByName = document.getElementsByName("yourElementName");
```


These methods provide different ways to locate and interact with HTML elements in a document using JavaScript. Choose the appropriate method based on your specific needs and the structure of your HTML document.


## **Changing HTML Elements**


Changing HTML elements dynamically is a fundamental aspect of web development, and JavaScript provides several methods to achieve this. Here are some commonly used methods for changing HTML elements:

1. **`innerHTML`****:**
	- **Purpose:** Changes the HTML content (including tags) of an element.
	- **Example:**

		```javascript
		document.getElementById("myElement").innerHTML = "New content";
		```

2. **`textContent`****:**
	- **Purpose:** Changes the text content of an element, excluding HTML tags.
	- **Example:**

		```javascript
		document.getElementById("myElement").textContent = "New text content";
		```

3. **`setAttribute`****:**
	- **Purpose:** Sets the value of an attribute on an element.
	- **Example:**

		```javascript
		document.getElementById("myElement").setAttribute("class", "newClass");
		```

4. **`style`****:**
	- **Purpose:** Modifies the inline styles of an element.
	- **Example:**

		```javascript
		document.getElementById("myElement").style.color = "blue";
		```

5. **`classList`****:**
	- **Purpose:** Provides methods to add, remove, or toggle CSS classes on an element.
	- **Examples:**

		```javascript
		document.getElementById("myElement").classList.add("newClass");
		document.getElementById("myElement").classList.remove("oldClass");
		```

6. **`appendChild`****:**
	- **Purpose:** Adds a new child element to an existing element.
	- **Example:**

		```javascript
		var newElement = document.createElement("p");
		newElement.textContent = "New paragraph";
		document.getElementById("parentElement").appendChild(newElement);
		```

7. **`removeChild`****:**
	- **Purpose:** Removes a child element from its parent.
	- **Example:**

		```javascript
		var childToRemove = document.getElementById("childElement");
		document.getElementById("parentElement").removeChild(childToRemove);
		```

8. **`setAttribute`****:**
	- **Purpose:** Sets or changes the value of an attribute on an HTML element.
	- **Example:**

		```javascript
		document.getElementById("myElement").setAttribute("src", "new-image.jpg");
		```


These methods provide a diverse set of tools for us —developers to manipulate HTML elements dynamically, whether it's updating content, changing styles, or modifying attributes. The choice of method depends on the specific requirement and the nature of the change you want to apply.


### Example - using **`setAttribute`** to change an input field to a button:


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Change Input to Button Example</title>
</head>
<body>

    <input type="text" id="myInput" value="Type Something">
    <button onclick="changeToButton()">Change to Button</button>

    <script>
        function changeToButton() {
            // Get the input element
            var inputElement = document.getElementById("myInput");

            // Create a new button element
            var buttonElement = document.createElement("button");

            // Set attributes for the new button
            buttonElement.setAttribute("type", "button");
            buttonElement.setAttribute("onclick", "alert('Button Clicked!')");
            buttonElement.innerHTML = "Click Me";

            // Replace the input with the new button
            inputElement.parentNode.replaceChild(buttonElement, inputElement);
        }
    </script>

</body>
</html>
```


In this example, an input field with the id "myInput" is initially present, alongside a button labeled "Change to Button." Clicking this button triggers the **`changeToButton`** function, wherein a new button is dynamically created using **`createElement`**. Key attributes (type and onclick) are set via **`setAttribute`**, and the input field is promptly replaced by this newly fashioned button using **`replaceChild`**. The outcome is a dynamic transformation, demonstrating the capability to swap an input field for a button upon clicking "Change to Button," complete with an onclick attribute for interactive functionality.


## Adding HTML Elements:

1. **`createElement`** **Method:**
	- **Purpose:** Creates a new HTML element.
	- **Example:**

		```javascript
		var newElement = document.createElement("div");
		```

2. **`appendChild`** **Method:**
	- **Purpose:** Appends a new child element to an existing element.
	- **Example:**

		```javascript
		var parentElement = document.getElementById("parent");
		parentElement.appendChild(newElement);
		```

3. **`insertBefore`** **Method:**
	- **Purpose:** Inserts a new element before a specified existing element.
	- **Example:**

		```javascript
		var existingElement = document.getElementById("existing");
		parentElement.insertBefore(newElement, existingElement);
		```

4. **`innerHTML`** **Property:**
	- **Purpose:** Sets or gets the HTML content inside an element.
	- **Example:**

		```javascript
		parentElement.innerHTML = "<p>New content</p>";
		```

5. **`insertAdjacentHTML`** **Method:**
	- **Purpose:** Inserts HTML into a specified position relative to the element.
	- **Example:**

		```javascript
		parentElement.insertAdjacentHTML("beforeend", "<p>New content</p>");
		```


## Deleting HTML Elements:

1. **`removeChild`** **Method:**
	- **Purpose:** Removes a child element from its parent.
	- **Example:**

		```javascript
		var childElement = document.getElementById("child");
		parentElement.removeChild(childElement);
		```

2. **`remove`** **Method (Modern Browsers):**
	- **Purpose:** Removes the element itself.
	- **Example:**

		```javascript
		var elementToRemove = document.getElementById("toRemove");
		elementToRemove.remove();
		```

3. **`replaceChild`** **Method:**
	- **Purpose:** Replaces a child element with a new element.
	- **Example:**

		```javascript
		var newChildElement = document.createElement("span");
		parentElement.replaceChild(newChildElement, oldChildElement);
		```

4. **`innerHTML`** **Property (Setting to an Empty String):**
	- **Purpose:** Sets the HTML content inside an element to an empty string, effectively removing its content.
	- **Example:**

		```javascript
		parentElement.innerHTML = "";
		```

5. **`outerHTML`** **Property:**
	- **Purpose:** Replaces an element with its HTML content.
	- **Example:**

		```javascript
		var newHTML = "<p>New content</p>";
		parentElement.outerHTML = newHTML;
		```






# Query Selectors


Query Selectors allows developers to select and manipulate HTML elements in a document using CSS-like syntax. They provide a powerful and flexible way to target specific elements based on various criteria, such as element type, class, ID, or attribute.


Here are some common examples of using Query Selectors:

- **Selecting by Element Type:**

	```javascript
	var paragraphs = document.querySelectorAll('p');
	```

- **Selecting by Class Name:**

	```javascript
	var elementsWithClass = document.querySelectorAll('.className');
	```

- **Selecting by ID:**

	```javascript
	var elementWithId = document.querySelector('#elementId');
	```

- **Selecting by Attribute:**

	```javascript
	var elementsWithAttribute = document.querySelectorAll('[data-custom]');
	```

- **Combining Selectors:**

	```javascript
	var complexSelection = document.querySelectorAll('ul li.active');
	```


Query Selectors return either a NodeList (for `querySelectorAll`) or a single element (for `querySelector`). NodeList is a collection of nodes, which can be iterated through using methods like `forEach`.


In summary, Query Selectors provide a concise and versatile way to interact with HTML elements in a document, making it easier for developers to manipulate the content and structure of a webpage dynamically.


# DOM Node & Methods


The DOM (Document Object Model) is a programming interface that represents the structure of a document as a tree of objects, where each object corresponds to a part of the document. A DOM Node is a fundamental interface in the DOM hierarchy, representing a generic node in the tree structure. All elements, attributes, and text content in an HTML or XML document are nodes.


Here are some key points about DOM Nodes and their methods:


## Key Points:

1. **Node Types:**
	- Nodes can have different types, such as elements, text nodes, attributes, comments, etc.
	- The `nodeType` property is used to determine the type of a node.
2. **Hierarchy:**
	- Nodes are organized in a hierarchical structure, forming a tree.
	- The `parentNode` property allows you to access the parent node of a given node.
	- The `childNodes` property provides a NodeList of child nodes.
3. **Traversal:**
	- The `nextSibling` and `previousSibling` properties allow traversal to adjacent nodes.
	- The `firstChild` and `lastChild` properties give access to the first and last child nodes.

## Types Of Nodes


In the DOM (Document Object Model), nodes represent different parts of an HTML or XML document, forming a tree structure. There are various types of nodes, each serving a specific purpose. Here are the common types of nodes in the DOM:

1. **Element Nodes:**
	- **Description:** Represent HTML or XML elements.
	- **Access:** Accessed using methods like `getElementById`, `getElementsByTagName`, or `querySelector`.
	- **Example:**
	The `<div>` element is an example of an element node.

		```html
		<div id="example">This is an element node</div>
		```

2. **Attribute Nodes:**
	- **Description:** Represent attributes of an HTML or XML element.
	- **Access:** Attributes can be accessed through the `attributes` property of an element node.
	- **Example:**
	In this example, `src` and `alt` are attribute nodes of the `<img>` element.

		```html
		<img src="example.jpg" alt="Example Image">
		```

3. **Text Nodes:**
	- **Description:** Contain the text content within an HTML or XML element.
	- **Access:** Accessed through the `textContent` or `innerText` property of an element node.
	- **Example:**
	The text "This is a text node" is a text node within the `<p>` element.

		```html
		<p>This is a text node</p>
		```

4. **Comment Nodes:**
	- **Description:** Represent comments within the HTML or XML document.
	- **Access:** Accessed through the `comment` property of a comment node.
	- **Example:**
	The content within `<!--`  and  `-->` is a comment node.

		```html
		<!-- This is a comment -->
		```

5. **Document Node:**
	- **Description:** Represents the entire document.
	- **Access:** The document node is the entry point for accessing the DOM tree.
	- **Example:**
	The `<html>` element serves as the document node in this example.

		```html
		<!DOCTYPE html>
		<html>
		  <head>
		    <title>Document Node Example</title>
		  </head>
		  <body>
		    <p>This is the document node.</p>
		  </body>
		</html>
		```

6. **Document Type Node:**
	- **Description:** Represents the document type declaration.
	- **Access:** Accessed through the `doctype` property of the document node.
	- **Example:**
	The `<!DOCTYPE html>` declaration is a document type node.

		```html
		<!DOCTYPE html>
		```


# DOM Events


DOM events are interactions or occurrences that take place in a web page, such as a user clicking a button, pressing a key, resizing the browser window, or the content of an input field changing. The HTML DOM (Document Object Model) allows JavaScript to respond to these events, enabling developers to create interactive and dynamic web applications. Here's an overview of DOM events and how JavaScript can react to them:


### Key Concepts:

1. **Event Types:**
	- Events can be triggered by various actions, such as mouse clicks (`click`), keyboard presses (`keydown`, `keyup`), form submissions (`submit`), document loading (`load`), and more.
2. **Event Targets:**
	- Events are associated with specific HTML elements, known as event targets. For example, a `click` event might be associated with a button, and a `change` event might be associated with a form input.
3. **Event Handlers:**
	- JavaScript can respond to events by using event handlers. Event handlers are functions that get executed when a specific event occurs.

### Reacting to Events:

1. **Inline Event Handlers:**
	- You can define event handlers directly within HTML elements using inline attributes like `onclick`, `onmouseover`, etc.

	```html
	<button onclick="myFunction()">Click me</button>
	```

2. **DOM Level 0 Event Handling:**
	- You can assign event handlers directly to JavaScript properties of DOM elements.

	```javascript
	var button = document.getElementById("myButton");
	button.onclick = function() {
	    // Handle the click event
	};
	```

3. **DOM Level 2 Event Handling:**
	- The `addEventListener` method is used to attach event handlers to elements. This method provides more flexibility and allows multiple handlers for the same event.

	```javascript
	var button = document.getElementById("myButton");
	button.addEventListener("click", function() {
	    // Handle the click event
	});
	```

4. **Event Object:**
	- Event handlers typically receive an event object that provides information about the event, such as the target element, mouse coordinates, key codes, etc.

	```javascript
	button.addEventListener("click", function(event) {
	    console.log("Button clicked!", event.target);
	});
	```


### Common Events:

1. **Click Event:**
	- Triggered when a mouse button is clicked.
2. **Keydown and Keyup Events:**
	- Fired when a key on the keyboard is pressed or released.
3. **Submit Event:**
	- Triggered when a form is submitted.
4. **Change Event:**
	- Fired when the value of an input field changes.
5. **Load Event:**
	- Occurs when a resource (like an image or script) and the entire page have finished loading.

### Example:


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Handling Example</title>
</head>
<body>

    <button id="myButton">Click me</button>

    <script>
        var button = document.getElementById("myButton");

        // Using DOM Level 2 event handling
        button.addEventListener("click", function() {
            alert("Button clicked!");
        });
    </script>

</body>
</html>
```


In this example, a click event handler is attached to a button using the `addEventListener` method. When the button is clicked, an alert is displayed.


Understanding DOM events and how to handle them is crucial for creating interactive and responsive web applications. Developers use events to capture user actions and trigger appropriate JavaScript functionality in response.


# The `onload` and `onunload` functions:


The `onload` and `onunload` events are part of the HTML DOM (Document Object Model) and are used to execute JavaScript code when a document or a page finishes loading (`onload`) or unloading (`onunload`). These events are commonly used to perform actions when a user enters or leaves a webpage.


## `onload` Event:


The `onload` event is triggered when a document or a webpage has finished loading. This event is often used to ensure that all resources, such as images and scripts, have been fully loaded before executing specific JavaScript code.


Example:


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>onload Event Example</title>
    <script>
        window.onload = function() {
            // Code to execute after the page has fully loaded
            alert("Page loaded!");
        };
    </script>
</head>
<body>
    <h1>Hello, World!</h1>
</body>
</html>

```


In this example, the `onload` event is used to display an alert when the page has finished loading.


## `onunload` Event:


The `onunload` event is triggered just before a document or a webpage is about to be unloaded, such as when the user navigates away from the page or closes the browser tab. This event is often used to perform cleanup tasks or prompt the user for confirmation before leaving the page.


Example:


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>onunload Event Example</title>
    <script>
        window.onunload = function() {
            // Code to execute before the page is unloaded
            alert("Goodbye! Come back soon.");
        };
    </script>
</head>
<body>
    <h1>Thanks for visiting!</h1>
</body>
</html>

```


In this example, the `onunload` event is used to display an alert just before the page is unloaded.


These events play a crucial role in managing the lifecycle of a web page and allow developers to execute code at specific points during the page's existence.


# DOM Event Listeners


DOM Event Listeners provide a more flexible and powerful way to handle events compared to traditional event attributes (e.g., `onclick`). Event Listeners allow you to attach multiple event handlers to a single event, making your code more modular and easier to maintain.


### Using `addEventListener`:


The `addEventListener` method is used to attach an event listener to an HTML element. It takes three parameters: the event type, the function to be executed when the event occurs, and an optional third parameter indicating whether the event should be captured during the event propagation phase.


### Syntax:


```javascript
element.addEventListener(eventType, eventHandler, useCapture);

```

- **`eventType`**: A string representing the type of event (e.g., "click", "keydown", "change").
- **`eventHandler`**: A function that will be called when the event occurs.
- **`useCapture`**: (Optional) A boolean value indicating whether to use the capturing phase (`true`) or the bubbling phase (`false`, default).

### Example of Multiple Event Listeners:


Here's a code snippet demonstrating the use of multiple event listeners on a button. In this example, we have a button that changes its color and displays a message when clicked, and it resets to its default state when the mouse leaves it:


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Event Listeners Example</title>
    <style>
        #myButton {
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <button id="myButton">Click me</button>

    <script>
        // Get the button element
        var button = document.getElementById("myButton");

        // Event listener for the "click" event
        button.addEventListener("click", function() {
            // Change the button color
            button.style.backgroundColor = "green";
            // Display a message
            alert("Button clicked!");
        });

        // Event listener for the "mouseenter" event
        button.addEventListener("mouseenter", function() {
            // Change the button color on mouse enter
            button.style.backgroundColor = "yellow";
        });

        // Event listener for the "mouseleave" event
        button.addEventListener("mouseleave", function() {
            // Reset the button color on mouse leave
            button.style.backgroundColor = "";
        });
    </script>

</body>
</html>
```


In this example:

- Clicking the button changes its color to green and triggers an alert.
- Hovering over the button changes its color to yellow.
- Moving the mouse away from the button resets its color to the default state.

Using multiple event listeners allows you to handle different aspects of user interaction separately, promoting cleaner and more organized code.


# Event Bubbling & Event Capturing


Event bubbling and event capturing are two phases of event propagation in the HTML DOM. When an event occurs on an HTML element, it goes through these two phases:

1. **Event Capturing (Capture Phase):**
	- In this phase, the event travels from the root of the DOM tree to the target element.
	- Event handlers attached with `useCapture` set to `true` are triggered during this phase.
2. **Event Bubbling (Bubbling Phase):**
	- In this phase, the event travels from the target element back up to the root of the DOM tree.
	- Event handlers attached without specifying `useCapture` or with `useCapture` set to `false` are triggered during this phase.

## Example of Event Capturing:


In the following example, we have a nested set of div elements, and we attach event listeners to the document capturing phase (`useCapture` set to `true`). When you click on the innermost div, you'll see that the event handlers for the capturing phase are triggered from the root to the target:


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Capturing Example</title>
</head>
<body>

    <div id="outer" style="border: 1px solid red; padding: 10px;">
        Outer
        <div id="middle" style="border: 1px solid green; padding: 10px;">
            Middle
            <div id="inner" style="border: 1px solid blue; padding: 10px;">
                Inner
            </div>
        </div>
    </div>

    <script>
        document.getElementById("outer").addEventListener("click", function() {
            console.log("Outer Capturing");
        }, true);

        document.getElementById("middle").addEventListener("click", function() {
            console.log("Middle Capturing");
        }, true);

        document.getElementById("inner").addEventListener("click", function() {
            console.log("Inner Capturing");
        }, true);
    </script>

</body>
</html>
```


When you click on the "Inner" div, you'll see in the console that the capturing phase event handlers are triggered in the order: Outer Capturing, Middle Capturing, Inner Capturing.


## Example of Event Bubbling:


In this example, event listeners are attached without specifying `useCapture` or with `useCapture` set to `false`. When you click on the innermost div, the event handlers are triggered in the bubbling phase from the target back up to the root:


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Bubbling Example</title>
</head>
<body>

    <div id="outer" style="border: 1px solid red; padding: 10px;">
        Outer
        <div id="middle" style="border: 1px solid green; padding: 10px;">
            Middle
            <div id="inner" style="border: 1px solid blue; padding: 10px;">
                Inner
            </div>
        </div>
    </div>

    <script>
        document.getElementById("outer").addEventListener("click", function() {
            console.log("Outer Bubbling");
        });

        document.getElementById("middle").addEventListener("click", function() {
            console.log("Middle Bubbling");
        });

        document.getElementById("inner").addEventListener("click", function() {
            console.log("Inner Bubbling");
        });
    </script>

</body>
</html>
```


When you click on the "Inner" div, you'll see in the console that the bubbling phase event handlers are triggered in the order: Inner Bubbling, Middle Bubbling, Outer Bubbling.


In practice, event bubbling is more commonly used, and the `useCapture` parameter is often omitted or set to `false` when attaching event listeners. Event capturing is less commonly used and is mainly applicable in specific scenarios where capturing is explicitly needed.

