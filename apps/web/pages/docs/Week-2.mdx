
# NodeJS and ExpressJS concepts


## Promises in JS

Promises are a JavaScript feature that provides a more structured and readable way to work with asynchronous code. They represent the eventual completion or failure of an asynchronous operation, allowing you to handle the result or error in a more organized and manageable manner.


### **Key Characteristics of Promises:**

1. **Asynchronous Operations:**
	- Promises are commonly used to handle asynchronous operations, such as fetching data from a server, reading a file, or executing a timer.
2. **States:**
	- A promise can be in one of three states:
		- **Pending:** The initial state, before the promise is resolved or rejected.
		- **Fulfilled (Resolved):** The operation completed successfully, and the promise has a resulting value.
		- **Rejected:** There was an error during the operation, and the promise has a reason for the failure.
3. **Chaining:**
	- Promises support chaining through the **`then`** method, allowing you to sequence asynchronous operations in a readable manner.
4. **Error Handling:**
	- Promises have built-in error handling through the **`catch`** method, making it easier to manage and propagate errors in asynchronous code.

### **Why Do We Need Promises?**

1. **Avoiding Callback Hell (Callback Pyramids):**
	- Promises help to mitigate the problem of callback hell, where nesting callbacks leads to unreadable and hard-to-maintain code.

	```javascript
	
	// Without Promises
	asyncOperation1((result1) => {
	  asyncOperation2(result1, (result2) => {
	    asyncOperation3(result2, (result3) => {
	      // ...
	    });
	  });
	});
	
	// With Promises
	asyncOperation1()
	  .then((result1) => asyncOperation2(result1))
	  .then((result2) => asyncOperation3(result2))
	  .then((result3) => {
	    // ...
	  });
	
	
	```

2. **Sequential Execution of Asynchronous Code:**
	- Promises provide a clean way to execute asynchronous operations sequentially, improving code readability.

	```javascript
	
	// Without Promises
	asyncOperation1((result1) => {
	  asyncOperation2(result1, (result2) => {
	    asyncOperation3(result2, (result3) => {
	      // ...
	    });
	  });
	});
	
	// With Promises
	asyncOperation1()
	  .then((result1) => asyncOperation2(result1))
	  .then((result2) => asyncOperation3(result2))
	  .then((result3) => {
	    // ...
	  });
	
	
	```

3. **Error Handling:**
	- Promises simplify error handling by providing a centralized **`catch`** block to handle errors for a sequence of asynchronous operations.

	```javascript
	
	asyncOperation1()
	  .then((result1) => asyncOperation2(result1))
	  .then((result2) => asyncOperation3(result2))
	  .catch((error) => {
	    console.error('An error occurred:', error);
	  });
	
	
	```

4. **Promise.all for Parallel Execution:**
	- Promises offer the **`Promise.all`** method, allowing parallel execution of multiple asynchronous operations and waiting for all of them to complete.

	```javascript
	
	const promise1 = asyncOperation1();
	const promise2 = asyncOperation2();
	
	Promise.all([promise1, promise2])
	  .then((results) => {
	    const result1 = results[0];
	    const result2 = results[1];
	    // ...
	  })
	  .catch((error) => {
	    console.error('An error occurred:', error);
	  });
	
	
	```


In summary, promises provide a cleaner and more organized way to work with asynchronous code, making it easier to read, write, and maintain. They address common challenges associated with callback-based code and promote better error handling and sequential execution of asynchronous operations.


### **Promises Basics:**

1. **Creating a Promise:**
	- A promise represents the eventual completion or failure of an asynchronous operation.
	- The **`Promise`** constructor takes a function with two parameters: **`resolve`** and **`reject`**.

	```javascript
	
	const myPromise = new Promise((resolve, reject) => {
	  // Asynchronous operation goes here
	  // If successful, call resolve with the result
	  // If there's an error, call reject with the error
	});
	
	
	```

2. **Resolving a Promise:**
	- Use the **`resolve`** function when the asynchronous operation is successful.

	```javascript
	
	const successfulPromise = new Promise((resolve, reject) => {
	  setTimeout(() => {
	    resolve('Operation succeeded!');
	  }, 1000);
	});
	
	
	```

3. **Rejecting a Promise:**
	- Use the **`reject`** function when there's an error during the asynchronous operation.

	```javascript
	
	const failedPromise = new Promise((resolve, reject) => {
	  setTimeout(() => {
	    reject('Operation failed!');
	  }, 1000);
	});
	
	
	```


### **Consuming Promises:**

1. **Using** **`then`** **and** **`catch`****:**
	- The **`then`** method is used to handle the resolved value.
	- The **`catch`** method is used to handle errors.

	```javascript
	
	successfulPromise
	  .then((result) => {
	    console.log(result); // Output: Operation succeeded!
	  })
	  .catch((error) => {
	    console.error(error); // This won't be called in this example
	  });
	
	
	```

2. **Chaining Promises:**
	- Promises can be chained using **`then`**. Each **`then`** returns a new promise.

	```javascript
	
	successfulPromise
	  .then((result) => {
	    console.log(result); // Output: Operation succeeded!
	    return 'New value';
	  })
	  .then((newValue) => {
	    console.log(newValue); // Output: New value
	  })
	  .catch((error) => {
	    console.error(error);
	  });
	
	
	```

3. **Promise All:**
	- **`Promise.all`** is used to wait for multiple promises to complete.

	```javascript
	
	const promise1 = Promise.resolve('One');
	const promise2 = Promise.resolve('Two');
	
	Promise.all([promise1, promise2])
	  .then((values) => {
	    console.log(values); // Output: ['One', 'Two']
	  })
	  .catch((error) => {
	    console.error(error);
	  });
	
	
	```


 Promises are essential for handling asynchronous code in a clean and readable way, especially when working with features like fetching data from a server, handling events, or working with timers.


## Express Server

# Create a simple express server

1. **Express Framework:**
	- **Purpose:** Express is a web application framework for Node.js, designed to simplify the process of building web applications and APIs.
	- **Routing:** Express provides a powerful routing mechanism that allows you to define how your application responds to different HTTP requests (e.g., GET, POST).
2. **HTTP Methods:**
	- **GET:** Used to retrieve data from the server. Typically used for reading information.
	- **POST:** Used to submit data to the server. Often used for creating or updating resources.
	- **Other Methods (PUT, DELETE, etc.):** Used for various purposes, such as updating or deleting resources.
3. **Routes:**
	- **Definition:** Routes define the paths in your application and the HTTP methods they respond to.
	- **Parameters:** Routes can have parameters that allow dynamic handling of different values.
4. **Request and Response Objects:**
	- **Request (****`req`****):** Represents the incoming HTTP request from the client. Contains information about the request, such as parameters, headers, and body.
	- **Response (****`res`****):** Represents the outgoing HTTP response to be sent back to the client. Allows you to send data, set headers, and more.
	1. **Listening and Ports:**
	- **Server Creation:** After defining routes and middleware, the Express application needs to be "listened" to for incoming requests.
	- **Port:** The server listens on a specific port (e.g., 3000) for incoming HTTP requests.

```javascript
//server.js
// Import the express module
const express = require('express');

// Create an instance of the express application
const app = express();

// Define a route for the root URL ("/")
app.get('/', (req, res) => {
  res.send('Hello, this is the root/main route!');
});

// Define another route for "/api" with JSON response
app.get('/api', (req, res) => {
  res.json({ message: 'This is the API route.' });
});

// Define a route with URL parameters
app.get('/greet/:name', (req, res) => {
  const { name } = req.params;
  res.send(`Hello, ${name}!`);
});

// Start the server on port 3000
const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```


# Run the server


```bash
node server.js
```


Visit **`http://localhost:3000`** in your browser, and you should see the response from the root route. You can also try accessing other defined routes (**`/api`**, **`/greet/:name`**).


## Nodemon

# Use nodemon to auto restart


Nodemon is a utility that monitors for changes in your source code and automatically restarts the server when changes are detected. To use Nodemon, you'll need to install it globally or locally in your project, and then you can start your server with Nodemon.


### To install nodemon globally


```bash
npm install -g nodemon
```


### To install locally in project


```bash
npm install --save-dev nodemon 
```


### **Use Nodemon to Start Your Server**


```bash
nodemon server.js
```

- With Nodemon, you can focus on your code, and the tool will take care of restarting your server whenever you make changes, making the development process smoother.

## Get & Post

## Difference

# Difference between GET and POST


**`GET`** and **`POST`** are two HTTP methods used to request and send data between clients and servers. They differ in their purpose, the way data is sent, and their impact on the server and the browser's history.


### **GET:**

1. **Purpose:**
	- **`GET`** is used to request data from a specified resource.
	- It is designed to retrieve information and should have no other effect.
2. **Data Submission:**
	- Data is appended to the URL as query parameters.
	- Limited amount of data can be sent because data is included in the URL, and URLs have a maximum length.
3. **Visibility:**
	- Parameters are visible in the URL, which can impact security when dealing with sensitive information.
4. **Caching:**
	- Requests can be cached by the browser, and URLs can be bookmarked.
	- It is idempotent, meaning multiple identical requests will have the same effect as a single request.
5. **Examples:**
	- Reading a blog post, searching on Google, fetching data from an API.

### **POST:**

1. **Purpose:**
	- **`POST`** is used to submit data to be processed to a specified resource.
	- It can be used to create or update a resource on the server.
2. **Data Submission:**
	- Data is sent in the request body, not in the URL.
	- Can send a large amount of data compared to **`GET`**.
3. **Visibility:**
	- Parameters are not visible in the URL, enhancing security.
4. **Caching:**
	- Requests are not cached by the browser, and URLs cannot be bookmarked.
	- It is not idempotent; multiple identical requests may have different effects.
5. **Examples:**
	- Submitting a form, uploading a file, making a payment.

### **When to Use Each:**

- **GET:** Use when you want to retrieve data from the server, and the request has no side effects. It's suitable for safe and idempotent operations.
- **POST:** Use when you want to submit data to the server, especially when the operation has side effects (e.g., creating a new resource on the server). It's suitable for non-idempotent operations.

In summary, the choice between **`GET`** and **`POST`** depends on the purpose of the request and the type of operation you are performing.


## Handling GET

# How to handle GET requests


Handling GET requests in an Express.js application involves defining routes that respond to GET HTTP requests. Here's a basic example of handling a GET request in an Express.js application:


```bash
const express = require('express');
const app = express();
const port = 3000;

// Define a simple GET route
app.get('/', (req, res) => {
  res.send('Hello, this is a GET request!');
});

// Define a route with a parameter
app.get('/greet/:name', (req, res) => {
  const { name } = req.params;
  res.send(`Hello, ${name}!`);
});

// Start the server
app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```


In this example:

1. We create an instance of the Express application using **`express()`**.
2. We define a simple GET route for the root URL (**`'/'`**) that responds with a message.
3. We define another GET route with a parameter (**`'/greet/:name'`**) that responds with a personalized greeting based on the parameter.
4. We start the server with **`app.listen`** on port 3000.

When you run this script (**`node filename.js`**) and visit **`http://localhost:3000`** in your browser, you should see the response from the root route. Additionally, visiting **`http://localhost:3000/greet/John`** should display a personalized greeting for the name "John."


This is a basic example, and in a real-world application, you would likely have more complex routes and logic. Express provides a flexible and powerful routing system, allowing you to handle different HTTP methods, route parameters, query parameters, and more.


## Handling Post

# How to handle POST request


When building web applications, it's common to use HTTP POST requests to send data from the client (e.g., a form submission) to the server. In Express.js, handling POST requests involves using middleware to parse the incoming data and defining route handlers to process the data accordingly.


## **Middleware for Parsing JSON and Form Data:**


Before handling POST requests, it's important to include middleware to parse the incoming data. Express provides built-in middleware for handling JSON and form data. Add the following middleware to your Express app:


```javascript
// Middleware to parse JSON and form data
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
```


## **Handling a POST Request:**


```javascript
// In-memory array to store text content
const textContent = [];

// Route to handle POST requests for adding text content
app.post('/add-content', (req, res) => {
  // Extract text content from the request body
  const newContent = req.body.content;

  // Validate the content (you might want to add more robust validation)
  if (!newContent) {
		// if there is an error it will send the code 400 and an error
    return res.status(400).json({ error: 'Content is required' });
  }

  // Add the content to the in-memory array
  textContent.push(newContent);

  // Respond with a success message
  res.status(201).json({ message: 'Content added successfully' });
});
```


## Response Object

# Sending response back to Client


In an Express.js application, you send a response back to the client using the **`res`** (response) object. The **`res`** object provides various methods to send different types of responses, such as text, JSON, HTML, and more. Here are some common ways to send responses back to the client:

1. **Sending Plain Text:**
	- Use the **`res.send`** method to send plain text.

	```javascript
	javascriptCopy code
	app.get('/', (req, res) => {
	  res.send('Hello, this is a plain text response!');
	});
	```

2. **Sending JSON:**
	- Use the **`res.json`** method to send a JSON response.

	```javascript
	javascriptCopy code
	app.get('/api/data', (req, res) => {
	  const data = { message: 'This is a JSON response.' };
	  res.json(data);
	});
	```

3. **Sending HTML:**
	- Use the **`res.send`** method to send HTML content.

	```javascript
	javascriptCopy code
	app.get('/html', (req, res) => {
	  const htmlContent = '<h1>This is an HTML response</h1>';
	  res.send(htmlContent);
	});
	```

4. **Redirecting:**
	- Use the **`res.redirect`** method to redirect the client to a different URL.

	```javascript
	javascriptCopy code
	app.get('/redirect', (req, res) => {
	  res.redirect('/new-location');
	});
	```

5. **Sending Status Codes:**
	- Use the **`res.status`** method to set the HTTP status code.

	```javascript
	javascriptCopy code
	app.get('/not-found', (req, res) => {
	  res.status(404).send('Page not found');
	});
	```

6. **Sending Files:**
	- Use the **`res.sendFile`** method to send files.

	```javascript
	javascriptCopy code
	const path = require('path');
	
	app.get('/file', (req, res) => {
	  const filePath = path.join(__dirname, 'files', 'example.txt');
	  res.sendFile(filePath);
	});
	```

7. **Setting Headers:**
	- Use the **`res.set`** method to set HTTP headers.

	```javascript
	javascriptCopy code
	app.get('/custom-header', (req, res) => {
	  res.set('X-Custom-Header', 'Custom Header Value');
	  res.send('Response with a custom header');
	});
	```


These examples showcase various ways to send responses back to the client based on different scenarios. The **`res`** object provides a versatile set of methods to handle a wide range of response types. Depending on the use case, you can choose the appropriate method to send the desired response to the client.


## Serving Routes

# How to serve different routes


Use the **`app`** object to define routes for different URLs. Routes are defined using HTTP methods (such as **`GET`**, **`POST`**, **`PUT`**, **`DELETE`**, etc.) and specify a callback function that gets executed when a request matches the specified URL and method.


```javascript
const express = require('express');
const app = express();
const port = 3000;

// get route
app.get('/', (req, res) => {
  res.send('Hello from GET route!');
});

// post route
app.post('/add', (req, res) => {
  res.send('Hello from POST route!');
});

// PUT route - updation
app.put('/put/:id', (req, res) => {
  res.send('Hello from PUT route!');
});

//DELETE route 
app.delete('/delete/:id', (req, res) => {
  res.send('Hello from DELETE route!');
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```


## Understanding ENV

# How to start PORT on an env variable


### Install dotenv package


Install the **`dotenv`** package using npm. This package allows you to load environment variables from a file.


```bash
npm install dotenv
```


### **Create a** **`.env`** **File:**


Create a file named **`.env`** in the root of your project. This file will contain your environment variables. Add a variable for the port, for example:


```bash
PORT=3000
```


### **Load Environment Variables in Your Express App:**


In your main Express application file (e.g., **`app.js`** or **`index.js`**), load the environment variables using **`dotenv`**. Add the following lines at the top of your file:


```javascript
require('dotenv').config();
```


### **Use the PORT Environment Variable:**


```javascript
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

// Rest of your Express app code...

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```


### **Run Your Express App:**


```bash
node app.js
```


## Parsing Body

# How to parse body in a POST request


To parse the body of a POST request in Express, you can use middleware to handle different types of data formats such as JSON or form data. Express provides built-in middleware for parsing JSON (**`express.json()`**) and form data (**`express.urlencoded()`**).


```javascript
const express = require('express');
const app = express();
const port = 3000;

// Middleware to parse JSON data
app.use(express.json());

// Middleware to parse form data
app.use(express.urlencoded({ extended: true }));

// POST route to handle form data
app.post('/form', (req, res) => {
  const formData = req.body;
  res.json({ receivedData: formData });
});

// POST route to handle JSON data
app.post('/json', (req, res) => {
  const jsonData = req.body;
  res.json({ receivedData: jsonData });
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```


## Parsing Headers

# How to parse headers in a GET request


In an Express.js application, you can access headers in a GET request through the **`req.headers`** object in the route handler. The **`req.headers`** object contains all the headers sent with the request, and you can extract and use specific headers as needed.


```javascript
const express = require('express');
const app = express();
const port = 3000;

app.get('/get-info', (req, res) => {
  // Access headers from req.headers
  const userAgent = req.headers['user-agent'];
  const acceptLanguage = req.headers['accept-language'];

  res.json({
    userAgent,
    acceptLanguage,
  });
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```


## Parsing Queries

# How to parse query parameters


In an Express.js application, query parameters can be parsed from the URL using the **`req.query`** object. Query parameters are usually included in the URL after the "?" character and separated by "&" ([https://www.google.com/searchq=what+is+query+parameter+in+node+js&sca_esv=589601647](https://www.google.com/search?q=what%20is%20query%20parameter%20in%20node%20js&sca_esv=589601647&sxsrf=AM9HkKl-6hyjsI1zuB3KR3gyWxgy_50Fnw%3A1702233948173&ei=XAd2ZeWNCsCPseMPtLKFyA8&ved=0ahUKEwjlq7jOw4WDAxXAR2wGHTRZAfkQ4dUDCBA&uact=5&oq=what%20is%20query%20parameter%20in%20node%20js&gs_lp=Egxnd3Mtd2l6LXNlcnAiIndoYXQgaXMgcXVlcnkgcGFyYW1ldGVyIGluIG5vZGUganMyBhAAGBYYHjILEAAYgAQYigUYhgMyCxAAGIAEGIoFGIYDMgsQABiABBiKBRiGAzILEAAYgAQYigUYhgNIyw5QvwRYrwxwAXgBkAEBmAG2AaABtQuqAQMwLjm4AQPIAQD4AQHCAgoQABhHGNYEGLADwgIEECMYJ8ICCxAAGIAEGIoFGJECwgIFEAAYgATiAwQYACBBiAYBkAYI&sclient=gws-wiz-serp)).


 Here's a simple example:


```javascript
const express = require('express');
const app = express();
const port = 3000;

app.get('/api/user', (req, res) => {
  // Access query parameters from req.query
  const userId = req.query.id;
  const name = req.query.name;

  // Process the parameters as needed
  const user = {
    id: userId,
    name: name,
  };

  // Send a JSON response with the parsed parameters
  res.json({ user });
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```


## JSON Response

# How to send JSON response


In an Express.js application, you can send a JSON response using the **`res.json()`** method. This method automatically sets the appropriate Content-Type header to **`application/json`** and sends the JSON-formatted response to the client.


```javascript
const express = require('express');
const app = express();
const port = 3000;

app.get('/get-json', (req, res) => {
  // Create an object to be sent as JSON
  const responseData = {
    message: 'This is a JSON response',
    data: {
      key1: 'value1',
      key2: 'value2',
    },
  };

  // Send the JSON response
  res.json(responseData);
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```


## Postman

# How to use POSTMAN


Postman is a popular API development and testing tool that allows you to make HTTP requests to a server and view the responses. It's commonly used for testing APIs during development.


### Download and Install Postman


Download and install Postman from the official website: [Postman Download](https://www.postman.com/downloads/).


### Open Postman:


On the Postman application interface, you'll encounter a screen with existing collections, but to create a new one, simply click on the "New" button located at the top left corner of the interface.


![Screenshot_2023-12-10_234644.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/10eec1d4-074b-4586-9c27-d8d2c9bfd82f/Screenshot_2023-12-10_234644.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T144944Z&X-Amz-Expires=3600&X-Amz-Signature=5975dc949dfbbe3164b324555d05b7c4b6b2262182c4e10bcfe1b0067f9c3175&X-Amz-SignedHeaders=host&x-id=GetObject)


Then you will see a screen similar to this one


![Screenshot_2023-12-11_000854.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/f3f56359-24dc-4a59-b7bd-150b3bc3a90e/Screenshot_2023-12-11_000854.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T144944Z&X-Amz-Expires=3600&X-Amz-Signature=537876891f4926500d9872a94ee758b4b3c56ab817f8abddb406bae190f6b434&X-Amz-SignedHeaders=host&x-id=GetObject)


Select the HTTP option and hit enter


![Screenshot_2023-12-11_000659.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/b0296a6e-adaf-40be-b7f8-244120dea2f2/Screenshot_2023-12-11_000659.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T144944Z&X-Amz-Expires=3600&X-Amz-Signature=d4db8ebca5f9d7f7063bf33c582314327794a5fcec14c96482916cfdee7c7d59&X-Amz-SignedHeaders=host&x-id=GetObject)


Place the URL where your server is running, in our case, it is [http://localhost:3000/](http://localhost:3000/). Select the appropriate method, which, in our case, is GET, and click the SEND button. You will receive the response, similar to what is shown above.

