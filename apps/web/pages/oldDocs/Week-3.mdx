
## Finishing Backend

---


# Finishing Backend, Starting Frontend


## Quick Recap


---


**Where we are.**


HTTP Servers, Middleware were covered in previous classes, will be continuing on Databases and Authentication.


![Screenshot_2023-06-25_at_6.38.19_AM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/138e5691-1ea5-4ec9-9519-e23c0820cd33/Screenshot_2023-06-25_at_6.38.19_AM.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150629Z&X-Amz-Expires=3600&X-Amz-Signature=407044bd889f653e354fd0c5e82830f52268592756bacfce274886f68f80b9c0&X-Amz-SignedHeaders=host&x-id=GetObject)


**Arrow Functions** : Another way to write functions.


```javascript
**// Typical way, what we are familiar with**

**function callback(err, data){
	console.log(data);
}**
fs.readFile('a.txt', 'utf-8', callback)
```


```javascript
**// Defining/Putting the same function inside.**

fs.readFile('a.txt', 'utf-8', **function (err, data){
	console.log(data);
}**)
```


```javascript
**// Arrow function, the modern and clean way.**

fs.readFile('a.txt', 'utf-8', **(err, data) => {
	console.log(data);
}**)
```


**Detailed difference between Arrow function vs Normal Function [ ADVANCE & EXTRA ]**

1. **Syntax** : In arrow function, an arrow,  `=>`  is used.

```javascript
**// Normal function**
function greet(name) {
  console.log("Hello, " + name + "!");
}

**// Arrow function**
const greetArrow = name => console.log("Hello, " + name + "!");

greet("John");           **// Output: Hello, John!**
greetArrow("John");      **// Output: Hello, John!**
```

1. **Binding of** `this`  **:** An arrow function within an object does not bind its own this value, instead inherit the `this` value from the enclosing context.

```javascript
**// Normal function**
const person = {
  name: "John",
  greet: function() {
    console.log("Hello, " + this.name + "!");
  }
};

person.greet();   **// Output: Hello, John!**

**// Arrow function**
const personArrow = {
  name: "John",
  greet: () => {
    console.log("Hello, " + this.name + "!");
  }
};

personArrow.greet();   **// Output: Hello, undefined!**
```

1. **Use of** **`arguments`** **:** arguments object is not available within arrow functions. Instead, you can use the rest parameter syntax (...args) to capture all the arguments passed to the arrow function.

```javascript
**// Normal function**
function **sum()** {
  let total = 0;
  for (let i = 0; i < **arguments**.length; i++) {
    total += arguments[i];
  }
  return total;
}

console.log(sum(**1, 2, 3**));      // Output: 6

**// Arrow function**
const sumArrow = **(...args)** => {
  let total = 0;
  for (let i = 0; i < **args**.length; i++) {
    total += args[i];
  }
  return total;
};

console.log(sumArrow(**1, 2, 3**)); // Output: 6
```

1. **Constructor** : Arrow functions can‚Äôt be used as constructor to create new object.

```javascript
**// Normal function**
function Person(name) {
  this.name = name;
}

**const john = new Person("John");**
console.log(john.name);   // Output: John

**// Arrow function (as constructor)**
const PersonArrow = name => {
  this.name = name;
};

**const johnArrow = new PersonArrow("John");**  // Throws TypeError: PersonArrow is not a constructor
```

1. **Event Handling**

```javascript
const button = document.querySelector("button");

button.addEventListener("click", function() {
  console.log(this);   **// Refers to the button element**
});

const buttonArrow = document.querySelector("button");

buttonArrow.addEventListener("click", () => {
  console.log(this);   **// Refers to the Window (global object)**
});
```


## Foundation for databases


---


> ‚ö†Ô∏è On storing todos/data in variable like `var` , is essentially storing in memory, if process/server/computer restarts, all data is lost.


**Storing Todos in a file**


`fs.readFile()`  returns a string like this, for example  `" [ { title : "Buy Groceries" } ] "` but we need an object, so to convert into ‚Äúobject type‚Äù we use `JSON.parse()`


```javascript
fs.readFile("todos.json", "utf8", (err, data) => {
    if (err) throw err;
    res.json(JSON.parse(data));
});
```


`fs.writeFile()` accepts only string as a type to write to a file, so we need to convert it into string using `JSON.stringify()`  


```javascript
fs.writeFile("todos.json", JSON.stringify(todos), (err) => {
      if (err) throw err;
      res.status(201).json(newTodo);
});
```


> üí° Writing data to file makes it persistent or didn‚Äôt lost on server restart, but this is not efficient way to do. So we have databases for storing data that gives superman powers.


## Connecting frontend to backend


---


**CORS** (Cross-Origin Resource Sharing)

Browsers by default implements the **Same-Origin Policy**, according to which they only allow the data to be fetched from its own URL, like **`google.com`** can only request data from **`google.com`** 


> üí° Same Origin Policy : Allows Request URL = Response URL


We have to implement CORS, to request a data from website/URL other than its own URL, like **`google.com`** want to request data from **`facebook.com`** . 


> üí° CORS : Allows Request URL ‚â† ResponseURL


**CORS Error Demonstration** : In the image below I am trying to access the resource from URL other than my own, `http://localhost:3000/todos`  . By default browsers allow Same Origin Policy, so it gets blocked.


![Screenshot_2023-06-26_at_1.37.39_PM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/f8380193-94d2-4414-b82b-4946b3b5769c/Screenshot_2023-06-26_at_1.37.39_PM.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150633Z&X-Amz-Expires=3600&X-Amz-Signature=547020fa3ee07d7c8c4ceea3904a6ba5678138c21cafdefbcae5dfe02e7bd3e3&X-Amz-SignedHeaders=host&x-id=GetObject)


**CORS Error Solution** : Serving frontend and backend from same URL. Here From `http://localhost:3000/` at `/` route, fetching the html page, and fetching the todos from `http://localhost:3000/todos` , hence no origin mismatch.


![Screenshot_2023-06-26_at_1.59.00_PM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/4370311c-038a-4001-b885-5569ff2ef32c/Screenshot_2023-06-26_at_1.59.00_PM.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150635Z&X-Amz-Expires=3600&X-Amz-Signature=eb65e5defd6cb57089b7e14716d0cf80d03272692a2e52bc101cc731cdf7ea36&X-Amz-SignedHeaders=host&x-id=GetObject)


**Another solution** : `npm install cors` in sever and write the code below


```css
const cors = require('cors')
app.use(cors())
```


**CORS Working and Headers [ ADVANCE & EXTRA ]**


CORS works by adding specific HTTP headers to the server's responses. When a browser receives a response from a server that includes these CORS headers, it determines whether to allow or block the response based on the requested origin and the server's configured CORS policy.


CORS-related HTTP headers

1. **Access-Control-Allow-Origin**: Specifies which origins are allowed to access and "*" to allow any origin.
2. **Access-Control-Allow-Methods**: Specifies the HTTP methods (e.g., GET, POST, PUT, DELETE) that are allowed.
3. **Access-Control-Allow-Headers**: This header lists the headers that are allowed to be included in the request.
4. **Access-Control-Allow-Credentials**: This header indicates whether the server allows credentials (such as cookies, HTTP authentication, or client-side SSL certificates) to be sent with the cross-origin request.
5. **Access-Control-Max-Age**: Specifies the maximum time (in seconds) that the browser should cache the preflight response.

> üí° **Simple requests**: For simple requests (GET or POST), the browser directly sends the request to the server, adding **`Origin`** 


> üí° **Preflight requests**: For more complex requests (PUT, DELETE), the browser first sends a preflight request (OPTIONS) to the server. The preflight request serves as a "permission request". Its like asking server do we have permission for the requests.


**Reference Resource**


[bookmark](https://youtu.be/4KHiSt0oLJ0)


[bookmark](https://youtu.be/PNtFSVU-YTI)


## Starting Frontend

# Foundation of Frontend | Reconciliation


## Finishing ToDo


---


> ‚ö†Ô∏è The following notes are primarily emphasising the essential concepts and learnings from the video. So recommended performing hands on coding to get essence of below.


**GET Todos** and log it to console as soon as page loads, for which in the logic below we must call the function.


```javascript
function getTodos(){
		fetch("http://localhost:3000/todos", { method: "GET"} )
		.then( res => res.json() )
		.then( data => console.log(data) )
	}

getTodos();
```


**POST Todo** from frontend to backend taking user entered value as data from the form‚Äôs Input field like text and that value from text field is obtained by using `value` property. Below is the demonstration of the same.


![Screenshot_2023-06-27_at_10.22.59_AM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/1dd45dc7-d2fd-45fd-adb2-29732c949180/Screenshot_2023-06-27_at_10.22.59_AM.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150636Z&X-Amz-Expires=3600&X-Amz-Signature=474556ded264eb31273c4a21e3542b2ab145c3ecdec47ca53dc46ceecb975161&X-Amz-SignedHeaders=host&x-id=GetObject)


```javascript
function onPress(){
		var title = **document.getElementById('title').value**;
		var description = **document.getElementById('description').value**;
		fetch("http://localhost:3000/todos", {
			**method**: "POST",
			**body**: JSON.stringify({
				title: title,
				description: description
			}),
			**headers**: {
				"Content-Type": "application/json"
            	}
		})
		.then( () => console.log("Sent"))
	}
```


> üí° Body of a `fetch` request must be a string or a ReadableStream. So we have to use the `JSON.stringify()`


**DOM Manipulation**


DOM (Document Object Model), think of DOM as your HTML page/elements. From manipulation, we mean changing/updating the content or anything in HTML. As when we get todos from the backend, we want to add the todos to our front page. This is **DOM manipulation** and also behaviour of a **Dynamic Website**. 


Properties to understand


> üí° Recommended trying these once.

1. `innerHTML` vs `outerHTML : Image below demonstrates, when the value of an element is accessed what output is expected, but when you assign a value it is parsed HTML, not plain text/string`

![Source : Link](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/bfdf3b84-3be6-4a3b-adec-8f9ce5475a70/innerHTML_vs_outerHTML.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150635Z&X-Amz-Expires=3600&X-Amz-Signature=52e37757da693bdbab2dfa0451c5f9398a66788ed7651454388203dc0fce128a&X-Amz-SignedHeaders=host&x-id=GetObject)

1. `textContent` vs `innerHTML`

![txtContent_vs_innerHTML.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/dab264fc-c7ff-42f2-b0f6-c21c2479d445/txtContent_vs_innerHTML.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150635Z&X-Amz-Expires=3600&X-Amz-Signature=a19666551b0dad26ecaa3177d79cd8a8cd49fa63b1fab0335ce18915c6faaf69&X-Amz-SignedHeaders=host&x-id=GetObject)

1. `value` Form elements, like text field have property named **value** to get the user entered text/value. Like in the example below, to get ‚ÄúJohn‚Äù and ‚ÄúDoe‚Äù we will use value property for the form fields.

![html_input_field.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/1616a1b7-3c3a-47e3-ab4e-d7a20e69f1b5/html_input_field.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150635Z&X-Amz-Expires=3600&X-Amz-Signature=0273f29fe325a78f91bc202951a5b517234cc0bc4fcc3e9c24dd601a633f9236&X-Amz-SignedHeaders=host&x-id=GetObject)

1. `createElement`  self-explanatory creates any HTML element like div, button etc.
2. `appendChild` think of append as **add**, it adds to the existing element.

![Screenshot_2023-06-27_at_1.27.42_PM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/adb4cf1e-57bf-4975-8f06-cfac69c9a05b/Screenshot_2023-06-27_at_1.27.42_PM.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150636Z&X-Amz-Expires=3600&X-Amz-Signature=cbe833ea7692ee2a5acf4fd66a6b48e23a6aa252ad33ad11d47965966d4d8380&X-Amz-SignedHeaders=host&x-id=GetObject)

1. `setAttribute`  this property adds the attribute along with the value to a HTML element.

![element-components.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/d8cf3984-27e3-4d8d-bc59-9c477cb5e61c/element-components.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150635Z&X-Amz-Expires=3600&X-Amz-Signature=208ebbc4a1d19c4462263f6c63c84d77dee2a9eb509f73bc460649880537b17c&X-Amz-SignedHeaders=host&x-id=GetObject)

1. `textContent` vs `innerText` : innerText returns visible text content of an element, while textContent returns the combined text of all the text nodes within the element.

```javascript
<div id="myElement">
  This is some <span style="display: none;">hidden</span> text.
</div>

const element = document.getElementById('myElement');

console.log(element.textContent); // Output: "This is some hidden text."
console.log(element.innerText);   // Output: "This is some text."
```


**Advise** : Create Todo App similar to this.


[bookmark](https://twitter.com/i/status/1672947333695152128)


**Adding to-do to mainArea**


To insert to-do like below, along with button having attribute.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/70de1b5c-56b6-4b63-bad7-bbd715032fc0/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150636Z&X-Amz-Expires=3600&X-Amz-Signature=e66d408a699cb13ab91df00191d5c208e592fdfc6eae898d5d6978c8185d61aa&X-Amz-SignedHeaders=host&x-id=GetObject)


This will be the JavaScript code.


```javascript
function addTodo(data) {
        
        var parentElement = document.getElementById("mainArea");
        var childElement = document.createElement("div");

        var grandChildElement1 = document.createElement("span");
        grandChildElement1.innerHTML = data.title

        var grandChildElement2 = document.createElement("span");
        grandChildElement2.innerHTML = data.description

        var grandChildElement3 = document.createElement("button");
        grandChildElement3.innerHTML = "Delete"
				grandChildElement3.setAttribute("onclick", "deleteTodo(" + data[i].id + ")")

        childElement.appendChild(grandChildElement1)
        childElement.appendChild(grandChildElement2)
        childElement.appendChild(grandChildElement3)

        parentElement.appendChild(childElement);
    }
```


## Diving into legacy frontends.


---


The concept below helps to understand why HTML, CSS, and JS wasn‚Äôt enough to build modern day apps.


**Reconciliation** : Auto updating the DOM/user interface(UI)/HTML as soon as state/variable changes. Think of state as variable, and UI/DOM as html elements. So whenever there is any change in state/variable, UI/DOM must update/react accordingly.


> üí° Reconciliation is like a motion sensor light that turns on when there is motion and turns off when there is no motion. The motion represents the state/variable, and the light's response represents the UI changes based on that state.


![Screenshot_2023-06-27_at_8.10.52_PM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/9989a237-614f-4b15-ae83-72f639c9310b/Screenshot_2023-06-27_at_8.10.52_PM.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150635Z&X-Amz-Expires=3600&X-Amz-Signature=844a4770ef45baf068c9dd68e1e0d15535a2152ee2d8fafc45cb1ee2fd2bbe46&X-Amz-SignedHeaders=host&x-id=GetObject)


> üí° Under the hood, frameworks like ReactJS, VueJS, AngularJS uses javascript properties like `appendChild` , `removeChild` , `createElement`. As browsers only understand JavaScript, so these are the fundamental to it.


> üí° The frameworks like ReactJS, VueJS, AngularJS came into picture to hide these complexities and long verbose code. Made us to focus on states.


**Building Reconciler** : Not an ideal one, it shouldn‚Äôt remove all and then add


```javascript
function createDomElements(data) {
  var parentElement = document.getElementById("mainArea");
  parentElement.innerHTML = "";
  for (var i = 0; i<data.length; i++) {
      var childElement = document.createElement("div");

      var grandChildElement1 = document.createElement("span");
      grandChildElement1.innerHTML = data[i].title

      var grandChildElement2 = document.createElement("span");
      grandChildElement2.innerHTML = data[i].description

      var grandChildElement3 = document.createElement("button");
      grandChildElement3.innerHTML = "Delete"
      grandChildElement3.setAttribute("onclick", "deleteTodo(" + data[i].id + ")")

      childElement.appendChild(grandChildElement1)
      childElement.appendChild(grandChildElement2)
      childElement.appendChild(grandChildElement3)
      parentElement.appendChild(childElement);
  }
}

window.setInterval(() => {
  let todos = [];
  for (let i = 0; i<Math.floor(Math.random() * 100); i++) {
    todos.push({
      title: "Go to gym",
      description: "Go to gym form 5",
      id: i+1
    })
  }
  
  createDomElements(todos)
}, 1000000)
```


## Auth and Database

# Backend ‚Äì Authentication, Databases


> üí° Respective assignments are referred for the coding/implementation understanding.


## Authentication


---


**Tokens**


Before a server sends a response for a request, it must validate if the user is the authentic. Like before accessing your Gmail, it must validate/authenticate that it is you only. 


The key thing to note is the server has to validate/authenticate it for every request.


One way is sending password and email every time with request, which is tedious & stupid, Another way is **tokens**, similar to tokens in metro.


It works like when you `login` successfully, server gives you a token and whenever something is requested, the token is sent along and server authenticates, that yes it is you only.


[bookmark](https://youtu.be/UBUNrFtufWo)


**Encryption :** way to scramble data so that only authorized parties can unscramble it.

1. **Reversible** : If you have key.

![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/6df03610-8e71-4755-98a7-3f53748b4217/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150638Z&X-Amz-Expires=3600&X-Amz-Signature=13e76baaa1074f9dba076f6502f9457cca3334fb936c3a06a9dd397cef83873e&X-Amz-SignedHeaders=host&x-id=GetObject)


> üí° Think of this as converting the string into non-readable format using a key, and can only be converted into readable format if you have that key.


**Hashing** : Converting a string into a fixed length string.

1. **One-Way Process**/**Irreversible** : Can‚Äôt get `Fox` from the output
2. **A small change is a Big Change** : A little change in the input will result in a significantly different hash value.

![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/b957709a-440f-4783-9476-d4e8d0ed7680/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150638Z&X-Amz-Expires=3600&X-Amz-Signature=dbb54c43deba8e53867be55848a5e1ca98cb899612356e2975ce1d2bd28b0875&X-Amz-SignedHeaders=host&x-id=GetObject)


> üí° A machine that gives the exact same output for the exact same input. A slight change, even if capital letter to small, output will drastically change.


## Authentication ‚Äì Coding


---

1. Install library `jsonwebtoken`
2. Import `const jwt = require('jsonwebtoken');`
3. Create a `secret key` any random string like `const secretKey = "madhav‚Äù`
4. To generate a token `jwt.sign(payload, secretKey, { expiresIn: '1h' })`
5. To verify or reverse `jwt.verify( token, secretKey, callback)`

```javascript
const authenticateJwt = (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (authHeader) {
    const token = authHeader.split(' ')[1];

    jwt.verify(token, secretKey, (err, user) => {
      if (err) {
        return res.sendStatus(403);
      }

      req.user = user;
      next();
    });
  } else {
    res.sendStatus(401);
  }
};
```


## Database


---



Since, **storing data in memory** lasts only as long as the application is running, and **storing data in files** is inefficient, slow and require a lot of code for reading and writing. That's why we have a dedicated tool called a database.



> üí° Well, how & why databases are better; ‚Äú**Pehley istimal karey phir vishvass kare**‚Äù üòÜ (First use it, then trust it),


**MongoDB** is M in ‚Äú**M**ERN‚Äù Stack. It is **open-source**, we can run locally, but cloud version is mostly used, will be continuing with that. Technically, MongoDB is classified as a **NoSQL database**, uses **JSON-like documents** with _optional schemas_.


> üí° SQL database is like storing data in Excel Sheet/Table like format.  
> NoSQL is like storing data in JSON files/documents.


**Terminology :** Analogy to known naming conventions

1. Collection = Table
2. Document = Row

**Example** : `Users` would be a `collection/table` which has `user` in each `row/document`


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/70e4611c-8155-4788-b450-8ea05f294486/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150638Z&X-Amz-Expires=3600&X-Amz-Signature=7dbb261c67b1387b65ddc10e9113f45369c85ad0ce00aa2b5fc9f66786ad6ecd&X-Amz-SignedHeaders=host&x-id=GetObject)


> üí° Under the hood, while each document/row is a separate entity within a collection/table, but they are not stored as individual files on the file system. Instead, they are stored together within data files managed by the MongoDB storage engine. So each document/row is individual and together at the same time.


## Database ‚Äì Coding


---


>  ‚ÄúTalk is cheap. Show me the code.‚Äù by¬†**Linus Torvalds.**   
> Will be learning implementation and code while solving hard exercise in assignment.


Install `mongoose`, another library to make our database connection, CRUD operations easier to code. **Extra nugget**, here our server is interacting with MongoDB, acting as an intermediate but in some apps, frontend directly talks with backend, like in `Firebase`


![Source : Link](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/14b7206e-4c7a-41d6-aa96-36b48de3cffe/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150637Z&X-Amz-Expires=3600&X-Amz-Signature=cb60a1a44647468e7d23de766072c409ce6a3fc10d1a9e1f145ce9575378e629&X-Amz-SignedHeaders=host&x-id=GetObject)


**Schema** is skeleton/structure/layout/blueprint, defines what will be inside that object. In MongoDB, it is optional, but it is good to have to ensure data is consistent. 


> üí° Think of this as a `template` or `signup` form, with all fields mandatory. Whenever data to be pushed, all fields must be intact or filled.


```javascript
const userSchema = new mongoose.Schema({
  username: {type: String}, // is equivalent to String 
  password: String, // Types can String, Number, Boolean etc.
  purchasedCourses: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Course' }] // reference
});
```


> ‚ö†Ô∏è In Mongoose, the default behaviour is not to enforce strict schema validation during the save operation. To achieve use, the `required: true`


```javascript
const adminSchema = new mongoose.Schema({
  username: { type: String, required: true },
  password: { type: String, required: true },
});
```


**Models** is equivalent to creating collections.


```javascript
const Users = mongoose.model('Users', userSchema)
// 'Users' inside the model function, is the name of collection
// need not to be same as variable name.
```


**Connection :** To connect with mongoDB, upon successful connection, collections are automatically created with given Schemas


```javascript
mongoose.connect( "String/DBName", { useNewUrlParser: true, useUnifiedTopology: true })
// Second param is optional but recommended to use to avoid errors.
```


**Async/Await** : It is a syntactic sugar on promise, simply another cleaner way to write promises.


```javascript
// This async Looking syntax of Promises

fetch('https://www.boredapi.com/api/activity')
.then(data => data.json())
.then(response => console.log(response.activity))
```


```javascript
// To this sync looking syntax of Promises

async function getActivity(){
  const data = await fetch('https://www.boredapi.com/api/activity');
  const response = await data.json()
  console.log(response.activity)
}

getActivity()
```


**Example** : Saving the new Admin


```javascript
**// Promise Version**

newAdmin.save()
  .then(savedAdmin => {
    console.log(savedAdmin);
  })
  .catch(error => {
    console.log('Error:', error);
  });
```


```javascript
**// Async/Await Version**

try {
  const savedAdmin = await newAdmin.save();
  console.log(savedAdmin);
} catch (error) {
  console.log('Error:', error);
}
```


> üí° An Async Syntax that looks like Sync Syntax. That‚Äôs all.   
> Note, it is just syntactic sugar, doesn‚Äôt block the thread, works the exact same way.


[bookmark](https://youtu.be/li7FzDHYZpc)


**Important Mongoose Functions**


`save()` : To save the object to the collection.


```javascript
const newAdmin = new Admins(obj);
newAdmin.save();
await newAdmin.save(); // another version
```


`find({})` : To get all the documents from a collection.


```javascript
const courses = await Courses.find({});
```


`findOne({...})` : To find an object with these properties corresponding value, if doesn‚Äôt exist returns `null(falsy)`


```javascript
const admin = await Admins.findOne({ username });
```


`findByIdAndUpdate` : Self -Explanatory, to find a document in the collection by its **`_id`** field and update it. Note that the id is the unique id generated by MongoDB


```javascript
const course = await Courses.findByIdAndUpdate(req.params.courseId, req.body, { new: true });
```


> ‚ö†Ô∏è **`{ new: true }`**: This is an option passed to the **`findByIdAndUpdate`** method. Setting **`new`** to **`true`** ensures that the updated document is returned as the result of the operation. By default, the method returns the original document before the update.


`findById` : To find a document in a collection based on its unique **`_id`** field.


```javascript
const course = await Course.findById(req.params.courseId);
```


`populate(thatProperty)` : to populate/fill the references to other documents.


```javascript
const user = await User.findOne({ username: req.user.username }).populate('purchasedCourses');
```


## Assignment Learnings

## 01 ‚Äì Course App


---


**Object Deconstructing** : A smart way to create variables out of an object with the names same as  properties name and value corresponding to that property. In the example below, It creates two variables `username` and `password` from the `req.headers` object with corresponding value.


```javascript
const { username, password } = req.headers;

console.log(username) // "madhav"
console.log(password) // "madhav123"
```


**Revisiting** `find()` 


```javascript
const numbers = [1, 2, 3, 4, 5];
const fi = numbers.find(element => element === 6);

console.log(fi); // Output: undefined(falsy)
```


**Object Creation Shorthand** : Below shorthand creates an object out using variables, where property name is variable name and its value is variable‚Äôs value.


```javascript
ADMINS.push({
  username,
  password
});
```


> üí° It is **headers** not ~~header~~


Code below is full of concepts :  `parseInt()`, update of courses by reference and `Object.assign(course, req.body)`


```javascript
app.put('/admin/courses/:courseId', adminAuthentication, (req, res) => {
  const courseId = **parseInt(req.params.courseId);**
  const course = COURSES.find(c => c.id === courseId);
  if (course) {
    **Object.assign(course, req.body);**
    res.json({ message: 'Course updated successfully' });
  } else {
    res.status(404).json({ message: 'Course not found' });
  }
});
```


Create a **global variable** for courseID, if using 1, 2, 3 etc. not inside the route.


We can **pass any number of middlewares** in a route.


We can **add object to request** in middleware `req.user = user`;


In `filter` function, we have to pass the boolean condition.


`indexOf`  : It is like asking index of this element in this array.


```javascript
const numbers = [1, 2, 3, 4, 5];

console.log(numbers.indexOf(3)); // Output: 2
console.log(numbers.indexOf(6)); // Output: -1
```


## 03 ‚Äì Data to Filesystem


---


Two essential concepts when read and write in this case. 

1. We write in string/stringify format.
2. So when to read, we have to parse that string/stringified format

```javascript
ADMINS = JSON.parse(fs.readFileSync('admins.json', 'utf8'));
fs.writeFileSync('admins.json', JSON.stringify(ADMINS));
```


> üí° Previous data state is stored in files, is initialized at time of server start. Write running application current and updated state is in the variables.


## 02 (Authentication) & 04 (Database)


---


These are covered with concept in Backend ‚Äì Database & Authentication


[Auth and Database](https://www.notion.so/0ed95fd33ffd4e8b8c2174cececfc812) 


## 05 Reconciler


---


Covered in Week-4


[Reconcilers](https://www.notion.so/707787a57dce4c7a88ab8364547ce041) 


[üò∏ Week-3-Assignment](https://github.com/100xDevs-hkirat/all-assignments/tree/main/week-3)

