
## Deployement 1.2

# Frontend Deployments Certificate Management


# Resources


---


[bookmark](https://slides.com/harkiratsingh-2/week-10-1)


[link_preview](https://github.com/100xDevs-hkirat/week-10)


# Linking/Pointing domain name to server.


---


**What is a domain name ?**


[Google.com](http://google.com/), [Amazon.com](http://amazon.com/) etc. these are domain names. As your name points to you, MacBook Air M1 points to a specific MacBook/Laptop, similarly a domain name points to a Server‚Äôs Address, technically called IP address. IP/Server‚Äôs address looks something like this 192.168.1.1. Since it is hard to remember, so we have domain names that resolves/translates to IP Address. 

Note : Like anything else, you have to purchase it.


> üí° In short, the Server‚Äôs Address looks something like this, 192.168.1.1. Since we hate/cannot remember numbers, so we have domain name, which automatically translates/resolves to corresponding IP address. Like anything else, you have to purchase it.


**How to do this ?**


Go to DNS and add the `A (Alias) Record` and `corresponding IP` given in Instance of AWS. Here we are adding subdomain and pointing to AWS server. Now what is subdomain ? That is your homework.


> ‚ö†Ô∏è Once you add this, it takes time to update, max 24 hours. Why ? Huge story, homework.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/b1fbbde7-6d20-4118-b7e3-bbd9705ccb1c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150822Z&X-Amz-Expires=3600&X-Amz-Signature=1f05ea89f37367bd2050536f61097bd20355fe16a7255f289f5babf7e7d92842&X-Amz-SignedHeaders=host&x-id=GetObject)


> ü§© Want to check the IP/Server‚Äôs Address of any domain name, visit the website below


[bookmark](https://www.site24x7.com/tools/find-ip-address-of-web-site.html)


# Ngnix as Reverse Proxy


---


### Running backend on Port 80


Our service/node app is running on `PORT 3000`, and to access that, we enter `ec2-16-171-198-44.eu-north-1.compute.amazonaws.com:3000`, have you ever done in real life access websites. Nope !!! üòÇ


This is what we are going to fix.


The moment we type `google.com` and hit enter, `PORT 80` (uses HTTP protocol, isn‚Äôt much safer) is appended at the end by default by browser. So, lets trying running backend on PORT 80, instead of 3000.


We see permission denied error.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/63b21744-6cc8-4266-80bb-27348b32815b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150820Z&X-Amz-Expires=3600&X-Amz-Signature=ede10036645a0146c7899a93d921e9baf4b99a883bf02ee7d86452d72eed9d50&X-Amz-SignedHeaders=host&x-id=GetObject)


### Fix 1 : node Command not found.


When we try to run backend on port 80 instead of 3000. You may get this error.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/fea96e10-0d77-4ef7-87c3-436091778c26/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150820Z&X-Amz-Expires=3600&X-Amz-Signature=99e480f40fb12cf838512d4c3d88b5ee7c1c392b2c08d99c3b0a4f58bbcc2270&X-Amz-SignedHeaders=host&x-id=GetObject)


We can fix the error above running the command below.


```bash
sudo node index.js

# if above sucks or doesn't work
which node # get the path and paste below
sudo {path} index.js # replace the path here.
sudo /home/ubuntu/.nvm/versions/node/v21.1.0/bin/node index.js # in my case
```


### Why Ngnix ?


Hmm, all looks good, isn‚Äôt it ?


But not. It is because we usually run multiple backends/frontends/services on single Server, Let's say on EC2. It is because cloud is expensive, and we want to `Utilise resources properly` /  `Paisa Vasool` and ngnix helps in `vasooling paisa`


> üòÇ In cloud, we pay per hour and want to make sure `Paisa is Vasooled` We will take help of `nginx`


`ngnix` is a process, this can do a bunch of things, but we are interested in reverse proxy. 


[bookmark](https://youtu.be/JKxlsvZXG7c?si=AoOG-GyLyNkVAbWc)


All domain name point to same machine via same port 80, but based on `url` it should check hit the corresponding service. Technically, reverse proxy is when it hits an another process before it hit final/end process. Sort of broker/middle-man.


### Forward vs Reverse Proxy


[bookmark](https://youtu.be/AuINJdBPf8I?si=-Pcwlzm_MYx4hzxi)


**Forward Proxy** - Client End


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/94b5bb1b-1a02-4b27-8c71-e27f3d7fb259/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150820Z&X-Amz-Expires=3600&X-Amz-Signature=ec40323bc6e5e0fd66a509226eae580512921353477470d11fa69804fe08c595&X-Amz-SignedHeaders=host&x-id=GetObject)


**Reverse Proxy** - Back End


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/82e0e734-c567-4580-bdb8-3b9838215e3f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150822Z&X-Amz-Expires=3600&X-Amz-Signature=c935ec012f03ff640386db0edaec402e71c0705981986b2c13aa1724141403ea&X-Amz-SignedHeaders=host&x-id=GetObject)


**An implementational example**


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/ba5c3026-8869-4e78-b783-12f736452284/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150820Z&X-Amz-Expires=3600&X-Amz-Signature=05ea7a3b7d2eb1b7ba4dc452ad0c80977897a3e58e19f65035535e39e0d196a6&X-Amz-SignedHeaders=host&x-id=GetObject)


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/288ff50c-ea8d-4d7f-b025-ff26f25c6cab/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150820Z&X-Amz-Expires=3600&X-Amz-Signature=4ef5b02e4bc95bad916e27c44c9456ec930f5ae7c09012c827f5c420e7463d8c&X-Amz-SignedHeaders=host&x-id=GetObject)


![Source : Link](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/fb0f7c10-ba84-4139-88b6-01889f9ed31c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150822Z&X-Amz-Expires=3600&X-Amz-Signature=02d4e705f9739ad006ff7755dc2ff3edc2fa796a194471594c1284b86b41940d&X-Amz-SignedHeaders=host&x-id=GetObject)


### Installing Ngnix


Run the command below


```bash
sudo apt-get install nginx
```


If you install successfully, you should see this.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/11e57bd8-03c7-48a6-a68e-06b2c6f2f00f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150820Z&X-Amz-Expires=3600&X-Amz-Signature=944374499f8ec052893e7f26146eebdaaa87694bad07218f04e488ab5a576bcc&X-Amz-SignedHeaders=host&x-id=GetObject)


### Configuring port 80


Below is the configuration file to set-up reverse proxy. 


```javascript
events {
    worker_connections 1024;
}

http {
    server {
        listen 80;
        server_name dev1.codesleepcode.com;

        location / {
            proxy_pass http://localhost:3000;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }
    }
}
```


```bash
/etc/nginx/nginx.conf # nginx.conf file location
sudo nginx -s reload # to reload the configuration 
```


> ‚ö†Ô∏è If permission denied, use `sudo` before the command.


### Other than localhost


Using custom name instead of [localhost](http://localhost/) locally in machine. Add host


> ‚ö†Ô∏è Basically instead of `http://localhost:3000` we can use `http://testing.com:3000`  
> as per below configuration


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/a745838d-7c7a-4f84-a796-92d839f85da0/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150825Z&X-Amz-Expires=3600&X-Amz-Signature=0c715a897c1ec8976898f98b9531484713c24e45276abcc05075fbed1fbfb15e&X-Amz-SignedHeaders=host&x-id=GetObject)


# Certificate Management


---


If there is **lock** when we browse a website it is `https`, if not or shows Not Secure it is `http`


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/a80ff18f-52b3-4b46-ac0c-46e900bebf4c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150825Z&X-Amz-Expires=3600&X-Amz-Signature=c74a3d856ddccc36609fba564f89e267c13f5dece9560d350a165439b4c252fa&X-Amz-SignedHeaders=host&x-id=GetObject)


> ‚ö†Ô∏è Data sent via **HTTP** is **plain text**, susceptible to eavesdropping. In contrast, **HTTPS** **encrypts** the data for security.


> üí° You can see the data is in plain text , try `wireshark` to capture network traffic.


### Certificates in depth


[bookmark](https://youtu.be/r1nJT63BFQ0?si=jZabJk-eyt1laHCZ)


Certificates can be bought from **Certificate Authorities** (CA) like GoDaddy, Amazon etc. but there is popular and reliant option [certbot](https://certbot.eff.org/). Installation is pretty straight forward


# Frontend Deployment


---


**Method 1** - Drag and Drop on Vercel, Netlify (Free CDNs)


Since the HTML, CSS, JS or React Code is same for every user, it is simply copied over pop servers of CDNs around the globe. üòÑ Do note that‚Äôs not the case in NextJS.


**Method 2** -  Run `npm run dev` on the EC2 server. An ugly way to do it.



**Method 3** -  S3/Creating your own CDN like Vercel, Netlify.



**Method 4** - ec2 instances? (Does this fix cors?)


**Below is code used for the practice**


[link_preview](https://github.com/100xDevs-hkirat/week-10)


**Backend/Server Code** - When we enter `localhost:3000` , the default route or resource requested is `index.html` . This can be server simply by creating `public` folder and adding the code below.


```java
app.use(express.static("public"));
app.use("/*", (req, res) => {
    res.sendFile(path.join(__dirname, "/public/index.html"))
})
```


**Frontend Code** - We cannot do `npm run dev` on production. Actually we need HTML, CSS, JS that can be spit out to every user. To create that run `npm run build` , which will spit out the required code in `dist` folder.


> üí° Here‚Äôs a catch you cannot directly run the index.js in dist to test it. It has to be server on a server.


To locally serve on server we can use a library called serve.


 


```bash
npm i -g serve # To install globally
serve # To start serving, make sure you are in that dist folder
server -p 5173 # To change the port
```


### Full Stack on 1 Port


Basically, we are hosting frontend and backend on same port. Run the command below to achieve the same, make sure to add this to the scripts. This long command is nothing but combination of many commands in single line.


```bash
"start" : "cd ../admin-client && 
npm run build && 
rm -rf ../server/public && 
mkdir -p ../server/public && 
mv ./dist/* ../server/public && 
cd ../server && node index.js"
```


To start the npm using pm2, run the command below


```bash
pm2 start npm -- start
```


> ‚ö†Ô∏è Please note that this method is not the recommended approach for deploying both the frontend and backend. Its primary benefit is avoiding CORS (Cross-Origin Resource Sharing) errors, which are typically addressed in a production environment by implementing strict CORS policies and deploying the frontend and backend as separate entities.


# To be continued


---


üöÄ  Implementation URL

1. Nginx PORT 3000 - [http://ec2-13-48-5-59.eu-north-1.compute.amazonaws.com:3000](http://ec2-13-48-5-59.eu-north-1.compute.amazonaws.com:3000/)
2. Nginx PORT 3001 - [http://ec2-13-48-5-59.eu-north-1.compute.amazonaws.com:3001](http://ec2-13-48-5-59.eu-north-1.compute.amazonaws.com:3001/)
3. SSL + Domain + Full Stack Course Deployment- [https://dev1.codesleepcode.com](https://dev1.codesleepcode.com/)

The frontend deployment mentioned above works best only with ReactJS apps, since there is no server side rendering. But NextJS does Server Side Rendering. 

If this sounds little overhead, will be continued in 10.2


> ‚ö†Ô∏è We can use `httponly` cookie for authentication to be `xss` safe.


## NextJS

# Resources


---


[bookmark](https://slides.com/harkiratsingh-2/week-10-2)


[link_preview](https://github.com/100xDevs-hkirat/week-10.2)


# Problem with ReactJS


---


Before this we need understand difference between Client Side Rendering(**CSR**) vs Server Side Rendering(**SSR**), below is pretty nice video explains the same.


> üìå In nutshell, **CSR**(Client Side Rendering) shows an empty page before loading, while **SSR**(Server Side Rendering) displays a fully-rendered HTML page on the first load.


[bookmark](https://youtu.be/ObrSuDYMl1s?si=9VB6uGILENfZWkOt)


Below are the real life issues faced using React.


**Waterfalling** - The initial rendering or the first page load results to a blank screen. While this might not be immediately noticeable, it is one of the limitations in React.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/2ef380ea-0ca3-40f4-840d-0c972ecf9639/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150829Z&X-Amz-Expires=3600&X-Amz-Signature=7e3a2ea4b461315ab02414e24f126329880af76782ffbe78d3bc54a270851245&X-Amz-SignedHeaders=host&x-id=GetObject)


Here‚Äôs another visual explains the same about Client Side Rendering(**CSR**). Stages are **Loading** ‚Üí **Skeleton** ‚Üí **Full**, whereas in Server Side Rendering(**SSR**) we get **Fully-rendered Page**.


![Source - Link](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/68062fb6-3a46-40ee-bdd6-ad8e9de2a5e6/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150829Z&X-Amz-Expires=3600&X-Amz-Signature=f53d917d27dc61e2b39ea2f495b3d5fdd950a6e88a8515bd7774eb600ed3b876&X-Amz-SignedHeaders=host&x-id=GetObject)


**Lacks SEO Optimization** - SEO, or **S**earch **E**ngine **O**ptimization, is the process by which search engines like Google and Bing crawl websites to index/understand what the website is about, this is only possible when website has the content, keywords. The challenge with React is that it delivers contentless HTML(like in the image), along with bundle of JavaScript. Thus, indexing is not possible in react.


> üòÜ Crawling the content/html below, forget about browser, in fact even I/you cannot tell what‚Äôs this site about.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/6180a693-546c-4e5c-a86b-b9af1faba071/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150829Z&X-Amz-Expires=3600&X-Amz-Signature=a2787f9773b279ecee659ab00d9d25c709764c80104f4e04a37949d5085b2c8b&X-Amz-SignedHeaders=host&x-id=GetObject)


**Doesn‚Äôt work where JS can‚Äôt be executed(E-MAILs)** - In scenarios where JavaScript execution is restricted, such as within email clients like Gmail, client-side JavaScript won't execute. In such cases, it's necessary to send the final or pre-rendered HTML.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/80f3eec9-2dab-4fd0-977b-1650e7d9e371/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150829Z&X-Amz-Expires=3600&X-Amz-Signature=d3f90a59f381da53c529167590923fb4811072194b6a80d45382d69d61909757&X-Amz-SignedHeaders=host&x-id=GetObject)


# Why NextJS ?


---


[bookmark](https://youtu.be/WAMqFdCFotY?si=USiS6L7gNmtjDRab)


> üí° In Next.js, the key takeaway is that the initial page is server-side rendered, while all subsequent renders follow the standard React rendering process. Technically, each page or route is ‚Äúpre-rendered‚Äù + "hydrated" with ReactJS or JS  to make it interactive.


Following are the advantages on using NextJS

1. **Reduce the bundle size** : Since initial page is server-side rendered, large or heavy libraries can be process at backend, thus we can minimise the load on client side.
2. **Backend in NextJS** : We don‚Äôt separately need an express server we can do this inside the NextJS project. This also results in complete/direct access to backend and files.
3. **No blank page** on Initial Render, unlike in React application.

> ‚ö†Ô∏è Keep in Mind: During the initial page load, browser constructs like `localStorage` and `window` are not accessible on the server side. `localStorage` and `window` object are client side constructs.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/b6f89164-f840-49a8-b18d-09642db96306/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150829Z&X-Amz-Expires=3600&X-Amz-Signature=a055fc8d2af48b7991e9cd4ea81f215e1f9ad05f110ab4d0ea42dd8ecdf5fe44&X-Amz-SignedHeaders=host&x-id=GetObject)


# ReactJS to NextJS 


---


**Routing** is handled quite differently in NextJS, but it is smooth and easy. Rest 90% is all React.


Each page inside `pages` folder serve as a route.


```javascript
// For routing

const router = useRouter();
onClick= {() => router.push("/signup")} // Like adding on button click.
```


**Authentication via Cookies** : When using a GET request, it's important to note that local storage, tokens, and custom headers cannot be directly transmitted. GET requests typically include standard headers, and for authentication purposes we have to the use cookies for handling authentication in Next.js.


In essence, when you enter a URL in your browser and hit enter, the initial GET request doesn't include authentication headers or tokens. You can only include them in subsequent requests. This is why authentication is performed via cookies because cookies are automatically sent in every browser's GET request.


**getServerSideProps** : It is a function in Next.js that allows you to fetch data on the server and pre-render a page before it is sent to the client's browser.


**Dynamic Routing** **:** Folder structure below is an example of dynamic routing.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/30d7e130-d10c-484f-a165-cacd13502ffb/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150829Z&X-Amz-Expires=3600&X-Amz-Signature=dfeb43f2ed2d123eec32c10832349fff6545fc63c4aa6f1b203ae9f1489b0f48&X-Amz-SignedHeaders=host&x-id=GetObject)


**Server Side Components** vs **Client Side Components**

1. **Server Side Components (SSR)**: SSR components are initially **rendered on the server** before being sent to the client's browser.
	- This approach is used for pages that require dynamic data, SEO optimization, or authentication, as it ensures that the content is available when the page is loaded.
	- SSR is beneficial for improving SEO and ensuring content is visible to search engines.
2. **Client Side Components (CSR)**: CSR components are initially **rendered in the client's browser** using JavaScript.
	- This approach is suitable for pages that don't require SEO optimization, involve dynamic client-side interactions, or have content that can be loaded after the initial page render.
	- CSR is more interactive and can be quicker for navigating between pages within the application.

Next.js allows you to use a combination of both SSR and CSR, choosing the most appropriate rendering method for different parts of your application to achieve a balance between performance and functionality.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/9418ec2a-b45c-4a83-9fc7-c289a34e0255/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240118T150829Z&X-Amz-Expires=3600&X-Amz-Signature=0808ae1e1a3ace5c16f7fb556e66def2c5662d196cc2a7cdb8f4745e7adad29e&X-Amz-SignedHeaders=host&x-id=GetObject)


**App Router** vs **Pages Router**

