
> ðŸš§ Concepts in detail are covered here [Adv. State Management](https://www.notion.so/9dfc301d21144640b0bd2adbdf90a21b) 


## Existing State Management


---


So far state was defined, inside the component, due to which we canâ€™t pass it up to the parent, rather only down to the children.


![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/cb8017a6-2c6d-47aa-ae86-b88bfa757fd4/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240117%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240117T214823Z&X-Amz-Expires=3600&X-Amz-Signature=412fb11dba1fccd57f89be474de0a4cacdf72fb82364238ff8c26f3b532edbd3&X-Amz-SignedHeaders=host&x-id=GetObject)


So the **first UGLY way around** is to have all the states in App.jsx(the root parent component) and keep passing it down to children. Technically, rolling up the state up to App.jsx and re-rendering on state change.


> ðŸ’¡ UGLY way â€“ Rolling up all the states to the App.jsx(Root Parent) and on state change it triggers re-render.


## Better State Management


---


Issue with above solution is

1. Defining **all states at parent** are hard to maintain.
2. Useless **re-rendering** of all components.
3. **Prop-Drilling** : Keep passing the props down the tree, even if the child between doesnâ€™t need it.

> ðŸ’¡ The **Context API** only solves prop-drilling issue, but **Recoil** solves both prop-drilling and re-rendering (by rendering only the necessary components).


Having a global state and using state management libraries like `recoil` makes life easier.


Some state management libraries are

1. **Zustand** : The oldest.
2. **Redux** : Popular before recoil.
3. **Recoil** : The Open Source Choice & The Most Popular NOW!!

![Untitled.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4dd32e22-0b9d-4863-baa0-84dfdaf49ec9/57e95154-b2ff-4d4c-970b-ff7f39984c1c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240117%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240117T214823Z&X-Amz-Expires=3600&X-Amz-Signature=2e32e3221f5090000155890834b5e302d3674e16b80b8c304df11053546f93e4&X-Amz-SignedHeaders=host&x-id=GetObject)


> That separate folder having all states is usually called `store`


## Recoil


---


Below are the steps, else [**Must Read Doc**](https://recoiljs.org/docs/introduction/getting-started)


```typescript
// Install
npm install recoil
```


```typescript
// Wrap the component
import React from 'react';
import {
  RecoilRoot,
  atom,
  selector,
  useRecoilState,
  useRecoilValue,
} from 'recoil';

function App() {
  return (
    **<RecoilRoot>**
      <CharacterCounter />
    **</RecoilRoot**>
  );
}
```


```typescript
// Similar to state
const textState = atom({
  key: 'textState', // unique ID (with respect to other atoms/selectors)
  default: '', // default value (aka initial value)
});
```


**Selectors** = Sub-atom/part of an atom. Basically the idea is if we get value from the atom we get everything, but if we want only specific value that from the atom we use selectors.


> ðŸ’¡ Instead of `<RecoilRoot></RecoilRoot>` in app.jsx we can put in main.jsx.


> âš ï¸ Selector can be combination from multiple atoms


In short

- **Atom** = State
- **Selector** = Sub-part of the atom.
- **To set value** :  `const setUser = useSetRecoilState(userState)`
- **To get value** : `const user = useRecoilValue(userState)`

> ðŸ”¥ It is crucial to ensure that a component subscribes to the value only it requires.

